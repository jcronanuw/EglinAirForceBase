spread.type <- 0# necessary because this loop isn't producing new burnable area and you
#need to relocate the fire.
breaks <- 1022
break
}#10.2.2 --------------------------------------------------------------------------
#Ends loop if there are no more locations available for disturbance[e].
if(all(pr.3[,2] == 0))
{#10.3.1 --------------------------------------------------------------------------
#Reset tesn from zero to -1
tesn <- -1
#If spread type is 11, set to 0.
spread.type <- ifelse(spread.type == 11, 0, spread.type)
breaks <- 1031
break
} else #10.3.1 ---------------------------------------------------------------------
{ #10.3.2 --------------------------------------------------------------------------
pr.4 <- as.vector(pr.3[,2])/max(pr.3[,2])
#Reset new.cells object.
new.cells <- vector(length=0, mode = "numeric")
#This expression picks out which location values are of the same stand and are
#available (i.e. they are not occupied by the another disturbance) and makes sure
#that the mapped regime does not exceed its prescribed area.
fual <- s.profile[match(f.map[l.map %in% pr.3[,1]], f.probability[,1])]
#Multiply wind probability of spread by fuel-based probability of spread
pr.5 <- pr.4 * fual
#Ends loop if there are no more locations available for disturbance[e].
if(all(pr.5 == 0))
{#10.4.1 --------------------------------------------------------------------------
#Reset tesn from zero to -1
tesn <- -1
spread.type <- ifelse(spread.type == 11, 0, spread.type)#if spread type is 11, set to 0.
breaks <- 1041
break
} else #10.4.1 ---------------------------------------------------------------------
{ #10.4.2 --------------------------------------------------------------------------
#Rescale probability of spread to 1, this makes model run more efficiently without
#sacrificing differences in fuel/wind field properties.
pr.6 <- pr.5/max(pr.5)
#Produces a list with locations selected for each fuelbed.
new.cells <- unlist(mapply(function(y){
pr.3[y,1][resample(c(0,1), size = 1, replace = T, prob = c(1-pr.6[y], pr.6[y])) == 1]
},1:length(pr.3[,1])))
#Scale back the number of new cells if it will exceed area to be burned.
if((dema + length(ocod) + length(new.cells)) <= desa)
{
new.cells <- new.cells
} else
{
#If the number of new cells + dema exceeds dema then reduce the number of new cells.
new.cells <- resample(new.cells, (desa-(dema + length(ocod))))
}
osnd <- c(osnd, s.map[new.cells]) #tracks stand numbers involved in disturbance.
ocod <- c(ocod, new.cells) #tracks coordinates involved in disturbance.
s.map[new.cells] <- ((g*-1)-1) #maps disturbance.
if(spread.type == 11 & g >= 4 & length(unique(b.map[l.map %in% ocod])) > length(burned.units))
{
tesn_cum <- c(tesn_cum,((g*-1)-1))#update values representing pixels burned in this fire.
}
} #10.4.2 --------------------------------------------------------------------------
} #10.3.2 --------------------------------------------------------------------------
} else #10.1.1 ---------------------------------------------------------------------
{ #10.1.2 --------------------------------------------------------------------------
breaks <- 1012
break
} #10.1.2 --------------------------------------------------------------------------
if(spread.type == 12)
{#10.5.1
breaks <- 1051
break
} else#10.5.1
{#10.5.2
breaks <- 1052
}#10.5.2
} #10.0.0 --------------------------------------------------------------------------
} else #9.7.1 (WILDFIRE LOOP)--------------------------------------------------------------
{#9.7.2 (RX FIRE LOOP)--------------------------------------------------------------
#Establish disturbance[e] in s.map and record old stand number
if(spread.type == 12)
{
osnd <- c(osnd,s.map[scd])
ocod <- c(ocod, scd)
s.map[scd] <- s.map[scd] * tesn_t
} else
{
osnd <- c(osnd,s.map[scd])
ocod <- c(ocod, scd)
s.map[scd] <- s.map[scd] * tesn_t
} else
{
if(spread.type == 0)
{
if(length(scd) == 1)
{
osnd <- osnd
ocod <- ocod
s.map[scd[1]] <- scd.tesn
s.map[scd] <- s.map[scd] * tesn_t
tesn <- c(tesn, sort(unique(s.map[scd])))
} else
{
osnd <- c(osnd,s.map[scd[2:length(scd)]])
ocod <- c(ocod, scd[2:length(scd)])
s.map[scd[1]] <- scd.tesn
s.map[scd] <- s.map[scd] * tesn_t
tesn <- c(tesn, sort(unique(s.map[scd])))
}
} else
{
if(length(scd) == 1)
{
osnd <- osnd
ocod <- ocod
s.map[scd] <- s.map[scd] * tesn_t
} else
{
osnd <- c(osnd,s.map[scd[2:length(scd)]])
ocod <- c(ocod, scd[2:length(scd)])
s.map[scd] <- s.map[scd] * tesn_t
}
}
}
#LOOP 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11
#Loop 11 (by iterations). This loop keeps growing fire[e] in block[f]
#until growth stops.
for (h in 1:r.max)#h <- 2
{ #11.0.0 ---------------------------------------------------------------------------
#Area mapped for fire[e].
dema <- length(as.vector(s.map[s.map %in% loopF.NewStand]))
#This statement stops loop 11 when treatment[b] has been fully mapped.
if((dema + length(ocod)) < desa)
{ #11.1.1 ---------------------------------------------------------------------------
sdlo <- find_neighbors(find_actively_burning_cells_in_smap(), radius = 1)
#This object shows all unique locations available for establishment by treatment[b].
avlo <- unique(as.vector(l.map[sdlo][l.map[sdlo] %in% l.map[b.map %in% f.bun & s.map %in% ss2]]))
#Ends loop if there are no more locations available for treatment[b] in the
#block[cc] that is currently being mapped.
if(length(avlo) > 0)
{ #11.2.1 ---------------------------------------------------------------------------
#Reset new.cells object.
new.cells <- vector(length=0, mode = "numeric")
#This expression picks out which location values are of the same stand and are
#available (i.e. they are not occupied by the another treatment) and makes sure
#that the mapped regime does not exceed its prescribed area.
if((length(ocod) + length(avlo)) <= a.bun)#--------------------------A
{#-----------------------------------------------------------------A-TRUE
if((dema + length(ocod) + length(avlo)) <= desa)#------------------B
{#---------------------------------------------------------------B-TRUE
new.cells <- avlo
s.map[new.cells] <- s.map[new.cells]*tesn_t
tesn <- unique(s.map[s.map < 0 & s.map > NoData.Unit])
} else#----------------------------------------------------------B-TRUE
{#-------------------------------------------------------------B-FALSE
new.cells <- resample(avlo,(desa - (dema + length(ocod))))
s.map[new.cells] <- s.map[new.cells]*tesn_t
tesn <- unique(s.map[s.map < 0 & s.map > NoData.Unit])
}#-----------------------------------------------------------B-FALSE
} else #-----------------------------------------------------------A-TRUE
{#---------------------------------------------------------------A-FALSE
if((dema + length(ocod) + length(avlo)) <= desa)#--------------C
{#-----------------------------------------------------------C-TRUE
new.cells <- resample(avlo,(a.bun - length(ocod)))
s.map[new.cells] <- s.map[new.cells]*tesn_t
tesn <- unique(s.map[s.map < 0 & s.map > NoData.Unit])
spread.type <- 11
} else#------------------------------------------------------C-TRUE
{#---------------------------------------------------------C-FALSE
if(a.bun < desa)#----------------------------------------D
{#-----------------------------------------------------D-TRUE
new.cells <- resample(avlo,(a.bun - length(ocod)))
s.map[new.cells] <- s.map[new.cells]*tesn_t
tesn <- unique(s.map[s.map < 0 & s.map > NoData.Unit])
spread.type <- 11
} else#------------------------------------------------D-TRUE
{#---------------------------------------------------D-FALSE
new.cells <- resample(avlo,(desa - (dema + length(ocod))))
s.map[new.cells] <- s.map[new.cells]*tesn_t
tesn <- unique(s.map[s.map < 0 & s.map > NoData.Unit])
}#-------------------------------------------------D-FALSE
}#-------------------------------------------------------C-FALSE
}#-------------------------------------------------------------A-FALSE
osnd <- c(osnd, s.map[new.cells]) #tracks stand numbers involved in disturbance.
ocod <- c(ocod, new.cells) #tracks coordinates involved in disturbance.
} else #11.2.1 ----------------------------------------------------------------------
#Ends loop if there are no more locations available for treatment[b] in the
#block[cc] that is currently being mapped.
if(length(avlo) > 0)
{ #11.2.1 ---------------------------------------------------------------------------
#Reset new.cells object.
new.cells <- vector(length=0, mode = "numeric")
#This expression picks out which location values are of the same stand and are
#available (i.e. they are not occupied by the another treatment) and makes sure
#that the mapped regime does not exceed its prescribed area.
if((length(ocod) + length(avlo)) <= a.bun)#--------------------------A
{#-----------------------------------------------------------------A-TRUE
if((dema + length(ocod) + length(avlo)) <= desa)#------------------B
{#---------------------------------------------------------------B-TRUE
initial.new.cells <- avlo
fual <- f.map[match(initial.new.cells, l.map)]
ss.n <- length(fual)
ss <- rbinom(ss.n, 1,  f.probability[,2][match(fual, f.probability[,1])])
new.cells <- initial.new.cells[ss == 1]
s.map[new.cells] <- s.map[new.cells]*tesn_t
tesn <- unique(s.map[s.map < 0 & s.map > NoData.Unit])
} else#----------------------------------------------------------B-TRUE
{#-------------------------------------------------------------B-FALSE
initial.new.cells <- resample(avlo,(desa - (dema + length(ocod))))
fual <- f.map[match(initial.new.cells, l.map)]
ss.n <- length(fual)
ss <- rbinom(ss.n, 1,  f.probability[,2][match(fual, f.probability[,1])])
new.cells <- initial.new.cells[ss == 1]
s.map[new.cells] <- s.map[new.cells]*tesn_t
tesn <- unique(s.map[s.map < 0 & s.map > NoData.Unit])
}#-----------------------------------------------------------B-FALSE
} else #-----------------------------------------------------------A-TRUE
{#---------------------------------------------------------------A-FALSE
if((dema + length(ocod) + length(avlo)) <= desa)#--------------C
{#-----------------------------------------------------------C-TRUE
initial.new.cells <- resample(avlo,(a.bun - length(ocod)))
fual <- f.map[match(initial.new.cells, l.map)]
ss.n <- length(fual)
ss <- rbinom(ss.n, 1,  f.probability[,2][match(fual, f.probability[,1])])
new.cells <- initial.new.cells[ss == 1]
s.map[new.cells] <- s.map[new.cells]*tesn_t
tesn <- unique(s.map[s.map < 0 & s.map > NoData.Unit])
spread.type <- 11
} else#------------------------------------------------------C-TRUE
{#---------------------------------------------------------C-FALSE
if(a.bun < desa)#----------------------------------------D
{#-----------------------------------------------------D-TRUE
initial.new.cells <- resample(avlo,(a.bun - length(ocod)))
fual <- f.map[match(initial.new.cells, l.map)]
ss.n <- length(fual)
ss <- rbinom(ss.n, 1,  f.probability[,2][match(fual, f.probability[,1])])
new.cells <- initial.new.cells[ss == 1]
s.map[new.cells] <- s.map[new.cells]*tesn_t
tesn <- unique(s.map[s.map < 0 & s.map > NoData.Unit])
spread.type <- 11
} else#------------------------------------------------D-TRUE
{#---------------------------------------------------D-FALSE
initial.new.cells <- resample(avlo,(desa - (dema + length(ocod))))
fual <- f.map[match(initial.new.cells, l.map)]
ss.n <- length(fual)
ss <- rbinom(ss.n, 1,  f.probability[,2][match(fual, f.probability[,1])])
new.cells <- initial.new.cells[ss == 1]
s.map[new.cells] <- s.map[new.cells]*tesn_t
tesn <- unique(s.map[s.map < 0 & s.map > NoData.Unit])
}#-------------------------------------------------D-FALSE
}#-------------------------------------------------------C-FALSE
}#-------------------------------------------------------------A-FALSE
osnd <- c(osnd, s.map[new.cells]) #tracks stand numbers involved in disturbance.
ocod <- c(ocod, new.cells) #tracks coordinates involved in disturbance.
} else #11.2.1 ----------------------------------------------------------------------
{#11.2.2
#NOTE (12/6/2015)
#Fire has burned out and must be reassigned to a new area. Use spread.type = 0 to
#direct loop 9 into section that will locate anew scd
spread.type <- 0
breaks <- 1122
break
} #11.2.2 ---------------------------------------------------------------------------
} else #11.1.1 ----------------------------------------------------------------------
{ #11.1.2 ---------------------------------------------------------------------------
breaks <- 1112
break
} #11.1.2 ---------------------------------------------------------------------------
if(spread.type == 11)
{#11.3.1
#Save units that where burned so far.
burned.units <- c(burned.units, f.bun)
breaks < - 1131
break
} else #11.3.1
{#11.3.2
breaks <- 1132
}#11.3.2
} #11.0.0 ---------------------------------------------------------------------------
}#9.7.2 (RX FIRE LOOP)--------------------------------------------------------------
#NEW F.1.2---------------------------------------------------------------
#Reset tesn, it should be -1 for FDM, except in loop 10 where it must include multiple
#values to support the burn out function.
tesn <- -1#temporary stand number.
osnd <- abs(osnd)
#Show fuelbeds associated with stands affected by fire
fb_f12 <- Fuelbed.List[Stand.List %in% osnd]
#List corresponding stand numbers.
osno <- Stand.List[Stand.List %in% osnd]
#Expand fuelbeds to include each occurence of stand number in osnd
effb <- fb_f12[match(osnd, osno)]
#Calculate number of new stands
noef <- length(osno)
#Determine new stand numbers for treatment[b], block[cc].
if(noef == 0)
{
neef <- 0
} else
{
neef <- seq((mudn + 1), (mudn + noef), 1)
}
#Map new stands
od <- data.frame(ocod, osnd)
od <- od[order(od$ocod),]
v.neef <- neef[match(od$osnd, osno)]
s.map[l.map %in% od$ocod] <- v.neef
if(sum(neef) == 0)
{
neef <- 0
} else
{
neef <- seq((mudn + 1), (mudn + noef), 1)
}
#Map new stands
od <- data.frame(ocod, osnd)
od <- od[order(od$ocod),]
v.neef <- neef[match(od$osnd, osno)]
s.map[l.map %in% od$ocod] <- v.neef
if(sum(neef) == 0)
{
loopF.NewStand <- loopF.NewStand
loopF.Area <- loopF.Area
} else
{
loopF.NewStand <- c(loopF.NewStand,neef)
l.neef <- rep(1,length(v.neef))
s.neef_a <- summarize(l.neef, v.neef, sum)
s.neef <- as.vector(s.neef_a[,2])
loopF.Area <- c(loopF.Area, s.neef)
}
loopF.ReplacedStand <- c(loopF.ReplacedStand, osno)
loopF.E_no <- c(loopF.E_no, rep(e, length(osno)))
loopF.F_no <- c(loopF.F_no, rep(f, length(osno)))
loopF.G_no <- c(loopF.G_no, rep(g, length(osno)))
g.g <- sum(g.g, ifelse(g == 0,h,g))#tracks expansions
##############################################################################
##############################################################################
##############################################################################
#ONLY TO DIAGNOSE ERRORS FROM MODEL RUN 101                                 #
#DRAG ON TIME, REMOVE AFTER ERRORS DIAGNOSED                                #
if(length(unique(loopF.NewStand)) != length(loopF.NewStand) |
length(loopF.ReplacedStand) != length(loopF.NewStand) |
length(v.neef) != length(s.map[l.map %in% od$ocod]))
{
r101 <- 2
break
} else
{
r101 <- ifelse(any(s.map < 0 & s.map > -9999),22,0)
}
#TEMPOARY -- FORCES FDM TO CRASH IF -1 IS ASSSIGNED TO S.MAP
if(length(s.map[s.map < 0 & s.map > -9999]) > 0)
{
aaa <- data.frame(B = loopB.new_stand, F = loopF.NewStand)
} else
{
f <- f
}
#TEMPOARY -- FORCES FDM TO CRASH IF -1 IS ASSSIGNED TO S.MAP
} else #9.4.1 ----------------------------------------------------------------------
{ #9.4.2 ---------------------------------------------------------------------------
} #9.4.2 ---------------------------------------------------------------------------
} else #9.3.1 ----------------------------------------------------------------------
{ #9.3.2 ---------------------------------------------------------------------------
#Reset tesn, it should be -1 for FDM, except in loop 10 where it must include multiple
#values to support the burn out function.
tesn <- -1#temporary stand number.
osnd <- abs(osnd)
#Show fuelbeds associated with stands affected by fire
fb_f12 <- Fuelbed.List[Stand.List %in% osnd]
#List corresponding stand numbers.
osno <- Stand.List[Stand.List %in% osnd]
#Expand fuelbeds to include each occurence of stand number in osnd
effb <- fb_f12[match(osnd, osno)]
#Unique old stands
osno <- sort(unique(osnd))
#Calculate number of new stands
noef <- length(osno)
#Determine new stand numbers for treatment[b], block[cc].
if(noef == 0)
{
neef <- 0
} else
{
neef <- seq((mudn + 1), (mudn + noef), 1)
}
#Map new stands
od <- data.frame(osnd = osnd, ocod = ocod)
od <- od[order(od$ocod),]
v.neef <- neef[match(od.b$osnd, osno)]
s.map[s.map %in% osno] <- v.neef
#Log new stand numbers and associated disturbances when they have been added to
#s.map.
if(sum(neef) == 0)
{
loopF.NewStand <- loopF.NewStand
loopF.Area <- loopF.Area
} else
{
loopF.NewStand <- c(loopF.NewStand,neef)
l.neef <- rep(1,length(v.neef))
s.neef_a <- summarize(l.neef, v.neef, sum)
s.neef <- as.vector(s.neef_a[,2])
loopF.Area <- c(loopF.Area, s.neef)
}
loopF.ReplacedStand <- c(loopF.ReplacedStand, osno)
loopF.E_no <- c(loopF.E_no, rep(e, length(osno)))
loopF.F_no <- c(loopF.F_no, rep(f, length(osno)))
loopF.G_no <- c(loopF.G_no, rep(g, length(osno)))
g.g <- sum(g.g, ifelse(g == 0,h,g))#tracks expansions
##############################################################################
##############################################################################
##############################################################################
#ONLY TO DIAGNOSE ERRORS FROM MODEL RUN 101                                 #
#DRAG ON TIME, REMOVE AFTER ERRORS DIAGNOSED                                #
if(length(unique(loopF.NewStand)) != length(loopF.NewStand) |
length(loopF.ReplacedStand) != length(loopF.NewStand))
{
r101 <- 8
} else
{
r101 <- ifelse(any(s.map < 0 & s.map > -9999),88,0)
}
#TEMPOARY -- FORCES FDM TO CRASH IF -1 IS ASSSIGNED TO S.MAP
if(length(s.map[s.map < 0 & s.map > -9999]) > 0)
{
aaa <- data.frame(B = loopB.new_stand, F = loopF.NewStand)
} else
{
f <- f
}
#TEMPOARY -- FORCES FDM TO CRASH IF -1 IS ASSSIGNED TO S.MAP
break
} #9.3.2 ---------------------------------------------------------------------------
} else #9.1.1 ----------------------------------------------------------------------
{ #9.1.2 ---------------------------------------------------------------------------
break
} #9.1.2 ---------------------------------------------------------------------------
##############################################################################
##############################################################################
##############################################################################
} #9.0.0 ---------------------------------------------------------------------------
#Log new stand numbers and associated disturbances when they have been added to
#s.map.
loopE.NewStand <- c(loopE.NewStand,loopF.NewStand)
loopE.Area <- c(loopE.Area,loopF.Area)
loopE.ReplacedStand <- c(loopE.ReplacedStand,loopF.ReplacedStand)
loopE.E_no <- c(loopE.E_no, loopF.E_no)
loopE.F_no <- c(loopE.F_no, loopF.F_no)
loopE.G_no <- c(loopE.G_no, loopF.G_no)
loopE <- data.frame(NewStand = loopE.NewStand,
ReplacedStand = loopE.ReplacedStand,
Area = loopE.Area,
E_no = loopE.E_no,
F_no = loopE.F_no,
G_no = loopE.G_no)
loopE <- loopE[order(loopE$ReplacedStand),]
} else #8.1.1 ----------------------------------------------------------------------
{ #8.1.2 ---------------------------------------------------------------------------
#Log new stand numbers and associated disturbance when they have been added to
#s.map.
loopE.NewStand <- c(loopE.NewStand,loopF.NewStand)
loopE.Area <- c(loopE.Area,loopF.Area)
loopE.ReplacedStand <- c(loopE.ReplacedStand,loopF.ReplacedStand)
loopE.E_no <- c(loopE.E_no, loopF.E_no)
loopE.F_no <- c(loopE.F_no, loopF.F_no)
loopE.G_no <- c(loopE.G_no, loopF.G_no)
loopE <- data.frame(NewStand = loopE.NewStand,
ReplacedStand = loopE.ReplacedStand,
Area = loopE.Area,
E_no = loopE.E_no,
F_no = loopE.F_no,
G_no = loopE.G_no)
loopE <- loopE[order(loopE$ReplacedStand),]
} #8.1.2 ---------------------------------------------------------------------------
#Record date and time.
dt <- Sys.Date()
tm <- format(Sys.time(), format = "%H.%M.%S",
tz = "", usetz = FALSE)
#Tracking device
d.summary <- paste(
" Date: ", dt,
" Time: ", tm,
" Year: ", a,
" PercentComplete_ForYear: ", round(((which(tdn[tdy == a] == e)/
length(tdn[tdy == a]))*100),0),
" Disturbance_No: ", e,
" Name: ", f.disturbances$DisturbanceTitle[tdc[e]],
"MgmtOp: ", "N/A",
"BurnBlock: ", "N/A",
" BurnedArea_Expected: ", desa,
" BurnedArea_Actual: ", sum(loopE.Area),
"UnBurned_Area: ", desa-sum(loopE.Area),
" Blocks: ", f,
" Expansions: ", g.g,
"HiStandNo: ", max(neef))
# e.summary <- rbind(e.summary, d.summary)
#Save run data.
cat(d.summary, file = paste(output_path, "run_", run, "_disturbances.txt", sep = ""), fill = T, append = T)#
##############################################################################
##############################################################################
##############################################################################
#ONLY TO DIAGNOSE ERRORS FROM MODEL RUN 101                                  #
#DRAG ON TIME, REMOVE AFTER ERRORS DIAGNOSED                                 #
if(r101 > 0)                                                                 #
{                                                                            #
r101 <- r101
break
} else                                                                       #
{                                                                            #
r101 <- r101
}                                                                            #
#                                                                            #
} #8.0.0 ------------------------------------------------------------------#
}
