for (d in 1:r.max)#d <- 1
{ #4.0.0 ---------------------------------------------------------------------------
#Area mapped for treatment[b].
tbma <- length(s.map[s.map %in% c(tesn,loopC.new_stand)])
#This statement stops loop 4 when treatment[b] has been fully mapped.
if(tbma < tbsa)
{ #4.1.1 ---------------------------------------------------------------------------
#Object shows locations of 8 pixels surrounding each mapped pixel for
#disturbance[e].
sdlo <- find_neighbors(find_actively_burning_cells_in_smap(), radius = 1)
#This object shows all unique locations available for establishment by treatment[b].
avlo <- unique(l.map[sdlo][l.map[sdlo] %in% l.map[b.map == bun & s.map %in% elst]])
#Ends loop if there are no more locations available for treatment[b] in the
#block[cc] that is currently being mapped.
if(length(avlo) > 0)
{#4.2.1 ----------------------------------------------------------------------
#Reset new.cells object.
new.cells <- vector(length=0, mode = "numeric")
#Differentiate between spread of prescribed fires (continuous probabilities based
#on fuelbed) and silvicultural treatments (binary spread based on fuelbeds)
if(t.code == 3)
{
#PRESCRIBED FIRE
#Apply probability of ignition values to potentially burned cells to determine
#which will actually burn.
fual <- f.map[match(avlo, l.map)]
ss.n <- length(fual)
ss <- rbinom(ss.n, 1,  fuelbed_lut$probability_of_ignition[match(fual, fuelbed_lut$fuelbed)])
new.cells <- avlo[ss == 1]
} else {
#SILVICULTURAL TREATMENT
new.cells <- avlo
}
#This expression picks out which location values are of the same stand and are
#available (i.e. they are not occupied by the another treatment) and makes sure
#that the mapped regime does not exceed its prescribed area.
if((tbma + length(new.cells)) <= tbsa)
{
s.map[new.cells] <- s.map[new.cells]*tesn_t
osnt <- c(osnt, s.map[new.cells])
tesn <- unique(osnt)
ocot <- c(ocot, new.cells) #tracks coordinates involved in disturbance.
} else
{
new.cells <- resample(new.cells,(tbsa - tbma))
s.map[new.cells] <- s.map[new.cells]*tesn_t
osnt <- c(osnt, s.map[new.cells])
tesn <- unique(osnt)
ocot <- c(ocot, new.cells) #tracks coordinates involved in disturbance.
}
#Evaluate growth rate of prescribed fire and end loop 4 if growth
#rate has dropped below the predetermined cutoff
#Do not apply to silvicultural treatments.
if(t.code == 3)
{
#Determine if the rate of prescribed fire growth has dropped below 1% per
#iteration. When this happens the loop ends.
treatment.growth <- (length(new.cells)/tbsa)*100
if(treatment.growth > cutoff.growth.rate)
{#4.3.1----------------------------------------------------------------------
d <- d#placeholder
} else#4.3.1-----------------------------------------------------------------
{#4.3.2----------------------------------------------------------------------
breaks <- 432
break
}#4.3.2----------------------------------------------------------------------
} else
{
d <- d#placeholder
}
} else #4.2.1 ----------------------------------------------------------------------
{#4.2.2
breaks <- 422
break
} #4.2.2 ---------------------------------------------------------------------------
} else #4.1.1 ----------------------------------------------------------------------
{ #4.1.2 ---------------------------------------------------------------------------
breaks <- 412
break
} #4.1.2 ---------------------------------------------------------------------------
} #4.0.0 ---------------------------------------------------------------------------
#Find unique fuelbeds in each management unit
#Unique old stands
osto <- sort(unique(tesn))
#Log old stand numbers and area before they are changed in s.map.
loopC.old_stand <- c(loopC.old_stand,osto)
#Number of stands
nobc <- length(osto)
#Determine new stand numbers for treatment[b], block[cc].
nebc <- seq((masn + 1), (masn + nobc), 1)
#Map new stands
tn <- data.frame(osnt = osnt, ocot = ocot)
tn.b <- tn[order(tn$ocot),]
v.nebc <- nebc[match(tn.b$osnt, osto)]
s.map[l.map %in% tn.b$ocot] <- v.nebc
#Log new stand numbers and associated treatments when they have been added to s.map.
loopC.new_stand <- c(loopC.new_stand,nebc)
loopC.treat_type <- c(loopC.treat_type,rep(t.code,nobc))
loopC.new_mgmtUnit <- c(loopC.new_mgmtUnit,rep(bun, length(nebc)))
l.nebc <- rep(1,length(v.nebc))
s.nebc <- summarize(l.nebc,v.nebc,sum)
loopC.new_area <- c(loopC.new_area, as.vector(s.nebc[,2]))
} else #3.2.1 ----------------------------------------------------------------------
{ #3.2.2 ---------------------------------------------------------------------------
breaks <- 322
break
} #3.2.2 ---------------------------------------------------------------------------
} else #3.1.1 ----------------------------------------------------------------------
{ #3.1.2 ---------------------------------------------------------------------------
breaks <- 312
break
} #3.1.2 ---------------------------------------------------------------------------
d.d <- sum(d.d, d)#tracks expansions
} #3.0.0 ---------------------------------------------------------------------------
#Log new stand numbers and associated treatments when they have been added to s.map.
loopB.new_stand <- c(loopB.new_stand,loopC.new_stand)
loopB.treat_type <- c(loopB.treat_type, loopC.treat_type)
loopB.new_mgmtUnit <- c(loopB.new_mgmtUnit,loopC.new_mgmtUnit)
loopB.new_area <- c(loopB.new_area,loopC.new_area)
loopB.old_stand <- c(loopB.old_stand,loopC.old_stand)
loopB <- data.frame(new_stand = loopB.new_stand,
treat_type = loopB.treat_type,
new_mgmtUnit = loopB.new_mgmtUnit,
new_area = loopB.new_area,
old_stand = loopB.old_stand * -1)
loopB <- loopB[order(loopB$old_stand),]
#Print out run status
run_status(row.code, t.code, a, b, cc, e, f, tdn, tdy, tdc)
} else #2.4.1 ----------------------------------------------------------------------
{ #2.4.2 ---------------------------------------------------------------------------
#Register untreated area.
b.untreated[row.code] <- b.thresh$perc_cats[row.code] - b.treated[row.code]
meanUAA[t.code] <- sum(meanUAA[t.code], b.untreated[row.code])
#Log new stand numbers and associated treatments when they have been added to s.map.
loopB.new_stand <- c(loopB.new_stand,loopC.new_stand)
loopB.treat_type <- c(loopB.treat_type, loopC.treat_type)
loopB.new_mgmtUnit <- c(loopB.new_mgmtUnit,loopC.new_mgmtUnit)
loopB.new_area <- c(loopB.new_area,loopC.new_area)
loopB.old_stand <- c(loopB.old_stand,loopC.old_stand)
loopB <- data.frame(new_stand = loopB.new_stand,
treat_type = loopB.treat_type,
new_mgmtUnit = loopB.new_mgmtUnit,
new_area = loopB.new_area,
old_stand = loopB.old_stand * -1)
loopB <- loopB[order(loopB$old_stand),]
#Print out run status
break.message <- paste("Trtment Area Zero", sep = "")
run_status(row.code, t.code, a, b, cc, e, f, tdn, tdy, tdc)
} #2.4.2 ---------------------------------------------------------------------------
} else #2.3.1 ----------------------------------------------------------------------
{ #2.3.2 ---------------------------------------------------------------------------
#Print out run status
?install.packages
?entireScript
getwd()
#>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>          HOW WOULD YOU LIKE TO RUN THE FUELBED DYNAMICS MODEL?
#>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
#>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
#>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>          COMPUTING PARAMETERS...
#Do you want to install required R packages on this machine?
#Yes --- TRUE
#No ---- FALSE
INSTALL_PACKAGES <- FALSE
#Enable the graphics card as a processor for cellular automata sub-models?
#This will only work on machines with a Linux OS
#Yes --- TRUE
#No ---- FALSE
USE_GPU <- FALSE
#Would you like to replicate this run?
#If so use the same seed number for subsequent runs
#SEED is the starting point for psuedo random number generator
SEED <- sample(1:1000000,1)#764599
#Select a run ID, this should be a number, ideally unique that will help track this
#run. Output files are tagged with this ID number.
RUN <- 3003
#Reporting interval, how often (in model years) should output maps be produced?
#I.e., once every ... years.
#Must be less than model run time (YEARS object)
Interval <- 1
#What is your working directory. I.e. where are your input files coming from?
input_path <- "C:/Users/jcronan/Documents/GitHub/EglinAirForceBase"
#What is your output directory. I.e., here do you want maps and status reports to
#go?
output_path <- paste("C:/usfs_sef_outputs_FDM/results_r", RUN, "/", sep = "")
#Select pre-packaged or manually entered forest management and wildfire regime
#parameters + model run time (in years)
# FULL:   Actual paramater values derived from forest operations and wildfire data
#       for the period 2000-2015 and 50 year run
# QUICK:  Testing generates small areas of presribed fire and wildfire annually
#       and 2 year run.
# MANUAL: Manually enter disturbance parameters. Enter parameters below.
disturbance_regime <- "MANUAL"
if (disturbance_regime == "MANUAL")
{
#Number of years the model should run for.
YEARS <- 1
#Acres thinned annually.
THINNING <- 0
#Acres of herbicide application annually
HERBICIDE <- 0
#Acres prescribed burned annually
RX_FIRE <- 1000
#Natural fire rotation in years for:
#Element 1 -- Eglin Air Force Base
#Element 2 -- Surrounding 10-km buffer landscape
NATURAL_FIRE_ROTATION <- c(2054.38,2457.39)
#ACTUAL VALUES >> NATURAL_FIRE_ROTATION <- c(54.38,457.39)
#Mean fire size in acres for:
#Element 1 -- Eglin Air Force Base
#Element 2 -- Surrounding 10-km buffer landscape
MEAN_FIRE_SIZE <- c(4003.65,500.23)
#ACTUAL VALUES >> MEAN_FIRE_SIZE <- c(103.65,5.23)
#Standard deviation of mean fire size for:
#Element 1 -- Eglin Air Force Base
#Element 2 -- Surrounding 10-km buffer landscape
STAND_DEV_FIRE_SIZE <- c(1361.12, 113.98)
#ACTUAL VALUES >> STAND_DEV_FIRE_SIZE <- c(361.12, 13.98)
}
#>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
#>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
#>>>>>>>>>>>>>>>>>>>          HARD-CODED PARAMETERS -- THESE SHOULD NOT BE CHANGED
#>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
#>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
#>>>>>>>>>>>>>>>>>>>          COMPUTING PARAMTERS...
#Number of iterations for the following nested loops:
#Loop 2 (var. = b)    -- management actions
#Loop 3 (var. = cc)   -- blocks (management actions)
#Loop 4 (var. = d)    -- expansions (management actions)
#Loop 9 (var. = f)    -- blocks (wildfire)
#Loop 10 (var. = g)   -- expansions (unsuppressed wildfire)
#Loop 11 (var. = h)   -- expansions (wildfire with block and burn suppression)
r.max <- 1000#7
#Starting stand numbers for...
#------------------------------------------------------------------------------------------------
#Treatments:
treat.stand <- 400000000
#Fires:
fire.stand <- 800000000
#------------------------------------------------------------------------------------------------
#>>>>>>>>>>>>>>>>>>>          ASCII MAP FILE METADATA...
#The number of acres per pixel.
MapRes <- 0.22239
#Number of rows and columns in ascii map files.
rows <- 1771
cols <- 3491
#Number of rows with metadata for each ascii map file.
fh.adj <- 6  #fuelbed map (f.map)
sh.adj <- 6  #stand map (s.map)
bh.adj <- 6  #burn unit map (b.map)
lh.adj <- 6  #coordinate map (l.map)
#>>>>>>>>>>>>>>>>>>>          FOREST MANAGEMENT PARAMTERS...
#Vector of burn unit numbers (corresponds with b.map) that are within Eglin but
#unmanaged.
Unmanaged.Unit <- 9999
#Vector of burn unit numbers (corresponds with b.map) that are within the buffer
#perimeter.
Buffer.Unit <- 8888
#Vector of burn unit numbers (corresponds with b.map) that are outside of the
#Eglin perimeter. >> -9999
#For stand map, replace -9999 for No data cells with longer string.
NoData.Unit <- -9999999
#Number of start/ignition points. Select the proportion of available cells within a
#treatment unit to locate seed cells (i.e. start point locations that are fed into
#the cellilar automata sub-model.
#Element 1 -- Thinning
#Element 1 -- Herbicide Application
#Element 1 -- Prescribed Fire
seed.cells <- c(0.50, 0.50, 0.10)
#>>>>>>>>>>>>>>>>>>>          FUELBED PARAMTERS...
#Vector of fuelbed numbers (corresponds with f.map) with a fixed age at zero.
Fixed.Age <- c(-9999, 1061401, 1069000, 1071401, 5079000, 5089000, 5099000, 6000000)
#Open Water fuelbed
Open.Water <- 6000000
#Vector of fuelbed numbers (corresponds with f.map) that are non-burnable.
Non.Flammable <- c(-9999, 5089000, 5099000, 6000000)
#Key to fuelbeds in two objects above
#-9999    No Data
#1061401  Shrub swamp
#1069000  Cleared wetland
#1071401  Herbaceous marsh
#5079000  Rangeland
#5089000  Agriculture
#5099000  Developed
#6000000  Open water
#>>>>>>>>>>>>>>>>>>>          FIRE BEHAVIOR PARAMTERS...
#Increasing this value will increase the probability cells will burn in a crown fire.
#Default should be 1.
crown.fire.multiplier <- 2
#Do not map wildfires below this value (in acres). Purpose is to reduce model run
#time by excluding small fires that do not impact vegetation at the landscape scale.
fire.cut <- 10
#Ceilings for forest management and wildfire disturbances
#------------------------------------------------------------------------------------------------
#Maximum annual area burned in wildfires
#Element 1 -- Eglin Air Force Base
#Element 2 -- 10-km buffer landscape
Truncate.AAB <- c(50000, 25000)
#Maximum fire size of wildfires
#Element 1 -- Eglin Air Force Base
#Element 2 -- 10-km buffer landscape
Truncate.Area <- c(12000, 6000)
#Maximum number of fires and treatments in a given year
#Element 1 -- Eglin Air Force Base
#Element 2 -- 10-km buffer landscape
#Element 3 -- Thnning Treatment (Corresponds with THINNING)
#Element 4 -- Herbicide Application (Corresponds with HERBICIDE)
#Element 5 -- Prescribed Fire (Corresponds with RX_FIRE)
Truncate.Number <- c(400, 800, 50, 50, 500)
#-------------------------------------------------------------------------------------------------
#These two parameters will cause flammability of fuels to slowly equilibrate
#as annual area burned increases. For these values (c.shape = 1.5 and
#s.scale = 0.1) equlibration begins when area burned for a fire in the unmanaged
#unit (management unit = 9999) or buffer zone (management unit = 8888)
#almost immediately as fire size grows and all but unburnable fuels equilibrate to
#1 by the time fire size equals 1100 acres (5000 pixels).
#When wildfires are burned by the block and burn method flammability of fuels is
#based on probability. The meaning of the scale.factor and dist.curve are flipped
#and corresponding values are randomly selected from each dataset
c.shape <- 1.5
c.scale <- 0.1
#Values to guide stochastic generation of treatments. Order is thinning, herbicide, and
#prescribed fire.
minSize <- c(5, 20, 1)#minimum treated stand size within a treatment unit
#Shape parameters are used to inform the beta distribution function that determines
#The percentage of a treatment unit to be effected for each treatment.
shape1 <- c(30, 30, 10)#shape 1 parameter
shape2 <- c(5,5, 2.5)#shape 2 parameter
#Flame extinction variable in wildfire loop (loop 10). After cell has burned
#for the specified number of expansion it burns out.
burn.out <- 3
#Size threshold where fires are primarily wind driven.
#Testing, 10,000 acres was my original limit. It seems to high.
windThresholdSize <- 1000#acres
#>>>>>>>>>>>>>>>>>>>          WIND DATA PARAMTERS...
#Describe probability of wind coming from a given direction.
#0 = North
#1 = Northeast
#2 = East
#3 = Southeast
#4 = South
#5 = SouthWest
#6 = West
#7 = Northwest
windProbs <- c(0.1,0.025,0.01,0.01,0.025,0.05,0.16,0.62)
#>>>>>>>>>>>>>>>>>>>          FINISHED
#>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
#>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
#################################################################################################
#################################################################################################
#STEP 01: Administrative Information
# Reads mutable parameters from AWS user data
try(host_sim_params <- read.table("host_sim_params.csv"), silent=TRUE)
host_sim_params <- read.csv("host_sim_params.csv")
if (exists("host_sim_params") && "run_id" %in% colnames(host_sim_params)) {
# from AWS user data
run <- as.character(host_sim_params$run_id)
} else if (exists("RUN")) {
# manual
run <- RUN
} else {
stop("No run id present.")
}
if (exists("host_sim_params") && "seed" %in% colnames(host_sim_params)) {
# from AWS user data
set.seed(host_sim_params$seed)
} else if (exists("SEED")) {
# manual
set.seed(SEED)
} else {
set.seed(NULL)
seed <- runif(1)*2e9
cat("Random seed used: ", seed, file=paste(run, "_dump.txt"))
set.seed(seed)  # replace seed with manual seed if desired
}
if (exists("host_sim_params") && "rx_fire" %in% colnames(host_sim_params)) {
# from AWS user data
RX_FIRE <- host_sim_params$rx_fire
}
if (exists("host_sim_params") && "use_gpu" %in% colnames(host_sim_params)) {
# from AWS user data
USE_GPU <- host_sim_params$use_gpu
} else if (exists("USE_GPU")) {
# manual, no need to do anything
} else {
USE_GPU <- FALSE
}
if (exists("host_sim_params") && "install_packages" %in% colnames(host_sim_params)) {
# from AWS user data
INSTALL_PACKAGES <- host_sim_params$install_packages
}
if (exists("host_sim_params") && "input_path" %in% colnames(host_sim_params)) {
# from AWS user data
input_path <- as.character(host_sim_params$input_path)
}
setwd(input_path)  # set working directory
if (exists("host_sim_params") && "output_path" %in% colnames(host_sim_params)) {
# from AWS user data
output_path <- as.character(host_sim_params$output_path)
}
if (exists("host_sim_params") && "disturbance_regime" %in% colnames(host_sim_params)) {
# from AWS user data
disturbance_regime <- as.character(host_sim_params$disturbance_regime)
}
#>>>>>>>>>>>>>>>>>>>          R PACKAGES...
#Manage packages.
if(INSTALL_PACKAGES == TRUE)
{
#Install packages
install.packages("Hmisc", repos="http://cran.fhcrc.org/")
install.packages("GenKern", repos="http://cran.fhcrc.org/")
install.packages("gtools", repos="http://cran.fhcrc.org/")
install.packages("stringr", repos="http://cran.fhcrc.org/")
#Open libraries
library(stringr)#for str_pad()
library(Hmisc) #for summarize()
library(GenKern)#for nearest()
library(gtools)  #for combinations()ge
library(utils)#for Rprof()
if(USE_GPU == T)
{
#Install GPU package
install.packages("gmatrix", repos="http://cran.fhcrc.org/")
#Open GPU library
library(gmatrix)#GPU package, will only work on a Linux machine
} else
{
#nothing
}
} else
{
#Open libraries
library(stringr)#for str_pad()
library(Hmisc) #for summarize()
library(GenKern)#for nearest()
library(gtools)  #for combinations()ge
library(utils)#for Rprof()
if(USE_GPU == T)
{
#Open GPU library
library(gmatrix)#GPU package, will only work on a Linux machine
}
}
#>>>>>>>>>>>>>>>>>>>          DISTURBANCE AND MODEL RUN TIME PARAMETERS...
#Disturbance and time parameters
if(disturbance_regime == "FULL")
{
#Number of years the model should run for.
YEARS <- 50
#Acres thinned annually.
THINNING <- 5000
#Acres of herbicide application annually
HERBICIDE <- 5000
#Acres prescribed burned annually
RX_FIRE <- 100000
#Natural fire rotation in years for:
#Element 1 -- Eglin Air Force Base
#Element 2 -- Surrounding 10-km buffer landscape
NATURAL_FIRE_ROTATION <- c(54.38,457.39)
#Mean fire size in acres for:
#Element 1 -- Eglin Air Force Base
#Element 2 -- Surrounding 10-km buffer landscape
MEAN_FIRE_SIZE <- c(103.65,5.23)
#Standard deviation of mean fire size for:
#Element 1 -- Eglin Air Force Base
#Element 2 -- Surrounding 10-km buffer landscape
STAND_DEV_FIRE_SIZE <- c(361.12,13.98)
} else if(disturbance_regime == "QUICK")
{
#Number of years the model should run for.
YEARS <- 2
#Acres thinned annually.
THINNING <- 0
#Acres of herbicide application annually
HERBICIDE <- 0
#Acres prescribed burned annually
#RX_FIRE <- 1000
#Natural fire rotation in years for:
#Element 1 -- Eglin Air Force Base
#Element 2 -- Surrounding 10-km buffer landscape
NATURAL_FIRE_ROTATION <- c(10554.38, 10457.39)
#Mean fire size in acres for:
#Element 1 -- Eglin Air Force Base
#Element 2 -- Surrounding 10-km buffer landscape
MEAN_FIRE_SIZE <- c(103.65, 5.23)
#Standard deviation of mean fire size for:
#Element 1 -- Eglin Air Force Base
#Element 2 -- Surrounding 10-km buffer landscape
STAND_DEV_FIRE_SIZE <- c(361.12, 13.98)
}
#################################################################################################
#################################################################################################
#STEP 02: Operational Parameters
#Stop model run if map production interval is greater than the number of model years.
if (Interval > YEARS) {
cat("Interval too high. Make interval less than year variable.")
stop("Interval too high. Make interval less than year variable.")
}
#Average annual area treated for thinning, herbicide, and prescribed fire.
#Read in third meanTAP parameter from file
if (exists("RX_FIRE")) {
# manual
meanTAP <- c(THINNING, HERBICIDE, RX_FIRE)
} else if (exists("host_sim_params") && "rxfire" %in% host_sim_params) {
# from AWS
meanTAP <- c(THINNING, HERBICIDE, host_sim_params$rxfire)
} else {
stop("No rxfire parameter found.")
}
#Convert area in acres to 30 m pixels
meanTAP <- round(meanTAP/MapRes,0)
getwd()
inputs
