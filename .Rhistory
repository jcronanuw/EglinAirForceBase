library(Hmisc) #for summarize()
library(GenKern)
library(SDMTools)
library(gtools)  #for combinations()
#Version 17e corresponds with model documentation
####################################################################################
####################################################################################
#STEP 1: Administrative Information
#Set working directory
setwd("C:/Users/jcronan/Documents/GitHub/EglinAirForceBase")
#Accept arguments from Rscript/command line
#args <- commandArgs(TRUE)
args <- read.table("sef_lut_schedule_treatment.csv", header=TRUE,
sep=",", na.strings="NA", dec=".", strip.white=TRUE)
args <- args[1,]
set.seed(args[1])#this prevents script from producing identical random numbers
#when running in parallel on the same machine.
#Number of rows and columns in ascii map files
rows <- 1771
cols <- 3491
tx <- 4
#Number of years to run model for:
Years <- 2
#Number of rows with metadata for each ascii map file
fh.adj <- 6#fuelbed map (f.map)
sh.adj <- 6#stand map (s.map)
bh.adj <- 6#burn unit map (b.map)
lh.adj <- 6#coordinate map (l.map)
#Unique identifier for this run/simulation --- using id column from treatment schedule
run <- args[1]
#Do not map fires below this value (in acres). Purpose is to reduce model run time
#by excluding small fires that do not impact vegetation at the landscape scale.
fire.cut <- 10
#Temporary tracking items to figure out why MU.List is being corrupted.
Loop.track <- list()
MU.track <- list()
mgmtUnit.track <- list()
a <- 0
b <- 0
cc <- 0
d <- 0
e <- 0
f <- 0
g <- 0
####################################################################################
####################################################################################
#STEP 2: Operational Parameters
MapRes <- 0.22239#The number of acres per pixel
Interval <- 5#6
r.max <- 1000#7
c.shape <- 1.5#8
c.scale <- 0.1#9
#These two parameters will cause flammability of fuels to slowly equilibrate
#as annual area burned increases. For these values (c.shape = 1.5 and
#s.scale = 0.1) equlibration begins when area burned for a fire in the unmanaged
#unit (management unit = 9999) or buffer zone (management unit = 8888)
#almost immediately as fire size grows and all but unburnable fuels equilibrate to 1
#by the time fire size equals 1100 acres (5000 pixels).
#When wildfires are burned by the block and burn method flammability of fuels is based on
#probability. The meaning of the scale.factor and dist.curve are flipped and corresponding
#values are randomly selected from each dataset
NFR <- c(2954.38,99457.39)#c(5000,10000)#Natural fire rotation in years for Eglin, Buffer, and Combined.
MFS <- c(103.65,5.23)#c(1000,200)#Mean fire size in acres for Eglin, Buffer, and Combined.
DFS <- c(361.12,13.98)#c(20,10)#Standard deviation of mean fire size for Eglin and Buffer and Combined.
Truncate.AAB <- c(50000,25000)#Maximum annual area burned
Truncate.Area <- c(12000,6000)#Maximum fire size
Truncate.Number <- c(400,800,50,50,500)#Maximum number of fires and treatments in a given year
#Order is number of fires in Eglin, fires in buffer zone, and treatments (thinning,
#herbicide, and prescribed fire) in Eglin.
#Vector of fuelbed numbers (corresponds with f.map) with a fixed age at zero.
Fixed.Age <- c(-9999,1061401,1069000,1071401,5079000, 5089000, 5099000, 6000000)
#Open Water fuelbed
Open.Water <- 6000000
#Vector of fuelbed numbers (corresponds with f.map) that are non-burnable.
Non.Flammable <- c(-9999, 5089000, 5099000, 6000000)
#Key to fuelbeds in two objects above
#-9999    No Data
#1061401  Shrub swamp
#1069000  Cleared wetland
#1071401  Herbaceous marsh
#5079000  Rangeland
#5089000  Agriculture
#5099000  Developed
#6000000  Open water
#Size threshold where fires are primarily wind driven
windThresholdSize <- 1000#acres
#Testing, 10,000 acres was my original limit. It seems to high.
#Vector of burn unit numbers (corresponds with b.map) that are within Eglin but unmanaged.
Unmanaged.Unit <- 9999
#Vector of burn unit numbers (corresponds with b.map) that are within the buffer perimeter.
Buffer.Unit <- 8888
#Vector of burn unit numbers (corresponds with b.map) that are outside of the Eglin perimeter.
NoData.Unit <- -9999999
#Staring stand numbers for...
#Treatments:
treat.stand <- 4000000
#Fires:
fire.stand <- 8000000
#Values to guide stochastic generation of treatments. Order is thinning, herbicide, and
#prescribed fire.
minSize <- c(5,20,1)#minimum treated stand size within a treatment unit
#Shape parameters are used to inform the beta distribution function that determines
#The percentage of a treatment unit to be effected for each treatment.
shape1 <- c(30,30,10)#shape 1 parameter
shape2 <- c(5,5,2.5)#shape 2 parameter
#Average annual area treated for thinning, herbicide, and prescribed fire.
#Read in third meanTAP parameter from file
meanTAP <- c(1000, 1000, as.numeric(args[3]))
#Convert area in acres to 30 m pixels
meanTAP <- round(meanTAP/MapRes,0)
#Proportion of available cells within a treatment unit to seed treatment.
seed.cells <- c(0.50,0.50,0.10)#thinning, herbicide, prescribed fire
####################################################################################
####################################################################################
#STEP 3: Import Spatial Database (Raster Subset)
f.map <- matrix(scan(paste("sef_fmap_v2_",rows,"x",cols,".txt",
sep = ""),skip = fh.adj),ncol=cols,byrow=T)#16
s.map <- matrix(scan(paste("sef_smap_092715_",rows,"x",cols,".txt",
sep = ""),skip = sh.adj),ncol=cols,byrow=T)#17
b.map <- matrix(scan(paste("sef_bmap_",rows,"x",cols,".txt",
sep = ""),skip = bh.adj),ncol=cols,byrow=T)#18
l.map <- matrix(scan(paste("sef_lmap_",rows,"x",cols,".txt",
sep = ""),skip = lh.adj),ncol=cols,byrow=T)#20
####################################################################################
####################################################################################
#STEP 4: Import Spatial Database (Pseudo-vector Subset)
Stand.List <- read.table(paste(
"sef_StandList_",rows,"x",cols,".txt",
sep = ""), header=TRUE,
sep=",", na.strings="NA", dec=".", strip.white=TRUE)
Stand.List <- as.vector(Stand.List[,2], mode = "numeric")#20
Stand.List <- Stand.List[-1]
Fuelbed.List <- read.table(paste(
"sef_FuelbedList_",rows,"x",cols,".txt",
sep = ""), header=TRUE,
sep=",", na.strings="NA", dec=".", strip.white=TRUE)
Fuelbed.List <- as.vector(Fuelbed.List[,2], mode = "numeric")#21
Fuelbed.List <- Fuelbed.List[-1]
Coord.List <- read.table(paste(
"sef_CoordList_",rows,"x",cols,".txt",
sep = ""), header=TRUE,
sep=",", na.strings="NA", dec=".", strip.white=TRUE)
Coord.List <- as.vector(Coord.List[,2], mode = "numeric")#21
Coord.List <- Coord.List[-1]
Age.List <- read.table(paste(
"sef_AgeList_",rows,"x",cols,".txt",
sep = ""), header=TRUE,
sep=",", na.strings="NA", dec=".", strip.white=TRUE)
Age.List <- as.vector(Age.List[,2], mode = "numeric")#22
Age.List <- Age.List[-1]
Area.List <- read.table(paste(
"sef_AreaList_",rows,"x",cols,".txt",
sep = ""), header=TRUE,
sep=",", na.strings="NA", dec=".", strip.white=TRUE)
Area.List <- as.vector(Area.List[,2], mode = "numeric")#23
Area.List <- Area.List[-1]
mfri.List <- read.table(paste(
"sef_mfriList_",rows,"x",cols,".txt",
sep = ""), header=TRUE,
sep=",", na.strings="NA", dec=".", strip.white=TRUE)
mfri.List <- as.vector(mfri.List[,2], mode = "numeric")#23
mfri.List <- mfri.List[-1]
T1E.List <- read.table(paste(
"sef_T1EList_",rows,"x",cols,".txt",
sep = ""), header=TRUE,
sep=",", na.strings="NA", dec=".", strip.white=TRUE)
T1E.List <- as.vector(T1E.List[,2], mode = "numeric")#24
T1E.List <- T1E.List[-1]
T2E.List <- read.table(paste(
"sef_T2EList_",rows,"x",cols,".txt",
sep = ""), header=TRUE,
sep=",", na.strings="NA", dec=".", strip.white=TRUE)
T2E.List <- as.vector(T2E.List[,2], mode = "numeric")#24
T2E.List <- T2E.List[-1]
D1E.List <- read.table(paste(
"sef_D1EList_",rows,"x",cols,".txt",
sep = ""), header=TRUE,
sep=",", na.strings="NA", dec=".", strip.white=TRUE)
D1E.List <- as.vector(D1E.List[,2], mode = "numeric")#25
D1E.List <- D1E.List[-1]
D2E.List <- read.table(paste(
"sef_D2EList_",rows,"x",cols,".txt",
sep = ""), header=TRUE,
sep=",", na.strings="NA", dec=".", strip.white=TRUE)
D2E.List <- as.vector(D2E.List[,2], mode = "numeric")#25
D2E.List <- D2E.List[-1]
MU.List <- read.table(paste(
"sef_MUList_",rows,"x",cols,".txt",
sep = ""), header=TRUE,
sep=",", na.strings="NA", dec=".", strip.white=TRUE)
MU.List <- as.vector(MU.List[,2], mode = "numeric")#25
MU.List <- MU.List[-1]
#Last line removes the first integer from the .List objects which contain the NoDate
#area and will not match up with any date in f.path, resulting in an error.
####################################################################################
####################################################################################
#STEP 5: Import Conditional Database
f.path <- read.table("sef_lut_pathways_succession.csv", header=TRUE,
sep=",", na.strings="NA", dec=".", strip.white=TRUE)
f.treatments <- read.table("sef_lut_menu_treatment.csv", header=TRUE,
sep=",", na.strings="NA", dec=".", strip.white=TRUE, stringsAsFactors = F)
f.disturbances <- read.table("sef_lut_menu_disturbance.csv", header=TRUE,
sep=",", na.strings="NA", dec=".", strip.white=TRUE, stringsAsFactors = F)
t.post <- read.table("sef_lut_pathways_silviculture.csv", header=TRUE,
sep=",", na.strings="NA", dec=".", strip.white=TRUE)
d.post <- read.table("sef_lut_pathways_fire.csv", header=TRUE,
sep=",", na.strings="NA", dec=".", strip.white=TRUE)
pda <- read.table("sef_lut_thresholds_disturbances.csv", header=TRUE,
sep=",", na.strings="NA", dec=".", strip.white=TRUE)
f.probability <- read.table("sef_lut_prob_burning.csv", header=TRUE,
sep=",", na.strings="NA", dec=".", strip.white=TRUE, stringsAsFactors = F)
f.wind <- read.table("sef_lut_prob_wind.csv", header=TRUE,
sep=",", na.strings="NA", dec=".", strip.white=TRUE)
b.unit <- read.table("sef_lut_burn_units.txt", header=TRUE,
sep=",", na.strings="NA", dec=".", strip.white=TRUE)
b.unit <- data.frame(unit = b.unit[,2], area_ac = b.unit[,3], thin= b.unit[,4],
herb = b.unit[,5], fire = b.unit[,6])#remove col 1 and rename cols 2-6.
b.block <- read.table("sef_lut_pathways_burnBlocks.csv", header=T,
sep=",", na.strings="NA", dec=".", strip.white=TRUE)
b.block <- b.block[-1,]#remove first row -- no data unit.
b.thresh <- read.table("sef_lut_threshold_mgmtOptions.csv", header=T,
sep=",", na.strings="NA", dec=".", strip.white=TRUE)
f.start <- read.table("sef_lut_pathways_fireStart.csv", header=T,
sep=",", na.strings="NA", dec=".", strip.white=TRUE)
f.start <- f.start[-1,]#remove first row -- no data unit.
####################################################################################
####################################################################################
#STEP 07: Simplify input data.
ttxm <- t.post[,-1]#removes the fuelbed column for t.post.
dtxm <- d.post[,-1]#removes the fuelbed column from d.post.
pdxm <- pda[,-1]#removes the fuelbed column from pda.
####################################################################################
####################################################################################
#STEP 08: Generate secondary data.
fblo <- 1:length(t.post$fuelbed)#fuelbed location.
fbls <- t.post$fuelbed#master list of fuelbeds.
trls <- 1:length(f.treatments$TreatmentName)#Creates a numeric code for treatments.
#Temporary stand numbers
#The first will be used to seed disturbance and the second will be used in the fire
#loop to progressively track expansion of the fire front (allows for fire to burn
#out).
tesn <- -1#temporary stand number.
tesn_t <- -1#used for treatment loop
s.map[s.map == -9999] <- NoData.Unit
eglin.area <- length(b.map[!b.map %in% c(Buffer.Unit,-9999)])
#pixels within Eglin's perimeter.
buffer.area <- length(b.map[b.map == Buffer.Unit & !f.map != Open.Water])
#pixels within the buffer landscape, excluding pixels with open water fuelbeds.
#Determine Area of BANSA units, these must be burned every year and will determine
#the amount of area burned in CCA units.
#assigns thresholds for CCA and BANSA management threshold which will be
#based on the relative areas of each management level.
BANSA.Area <- sum(Area.List[MU.List %in% b.block$BurnBlock[b.block$BANSA == 2]])
FF.e <- ((eglin.area*MapRes)/(NFR[1]*MFS[1]))#FF.e = Fire Frequency for Eglin
FF.b <- ((buffer.area*MapRes)/(NFR[2]*MFS[2]))#FF.b = Fire Frequency for buffer
Mu.e <- 2*log(MFS[1]) - 0.5*(log(DFS[1]^2 + MFS[1]^2))#mean of log transformed mean fire size
Mu.b <- 2*log(MFS[2]) - 0.5*(log(DFS[2]^2 + MFS[2]^2))#mean of log transformed mean fire size
Sigma.e <- sqrt(log(DFS[1]^2 + MFS[1]^2) - 2*log(MFS[1]))#variance of log transformed fire sizes
Sigma.b <- sqrt(log(DFS[2]^2 + MFS[2]^2) - 2*log(MFS[2]))#variance of log transformed fire sizes
#Pixels to search (y coordinates, difference from flame front)
search.set <- matrix(data = 0,48,2)             #Cellular automata input
search.set[,1] <- c(-1,-1,0,1,1,1,0,-1,
-2,-2,-2,-1,0,1,2,2,2,2,2,
1,0,-1,-2,-2,
-3,-3,-3,-3,-2,-1,0,1,2,3,3,3,3,3,3,3,2,1,0,-1,-2,-3,-3,-3)
#Pixels to search (x coordinates, difference from flame front)
search.set[,2] <- c(0,rows,rows,rows,0,-rows,-rows,-rows,
0,rows,(rows*2),(rows*2),(rows*2),(rows*2),(rows*2),rows,0,-rows,(-rows*2),
(-rows*2),(-rows*2),(-rows*2),(-rows*2),-rows,
0,rows,(rows*2),(rows*3),(rows*3),(rows*3),(rows*3),(rows*3),(rows*3),(rows*3),
(rows*2),rows,0,-rows,(-rows*2),(-rows*3),(-rows*3),(-rows*3),(-rows*3),
(-rows*3), (-rows*3),(-rows*3),(-rows*2), -rows)
distance.coefficient <- c(rep(1,8), rep(0.002,16), rep(0.001,24))
dcl <- length(distance.coefficient)#for wildfires
dcl_t <- 8#for treatments
#Vectors show number of pixels in each concentric ring of pixels around a burnign pixel.
wind.set1 <- rep(seq(1,8,1),3)
wind.set2 <- rep(seq(1,16,1),3)
wind.set3 <- rep(seq(1,24,1),3)
#Isolate each ring of pixels around burning pixel.
wind_1a <- f.wind$NorthWind[1:8]
wind_2a <- f.wind$NorthWind[9:24]
wind_3a <- f.wind$NorthWind[25:48]
#Code wind directions.
windDirs <- c(0,1,2,3,4,5,6,7)
#0 = North
#1 = Northeast
#2 = East
#3 = Southeast
#4 = South
#5 = SouthWest
#6 = West
#7 = Northwest
#Describe probability of wind coming from a given direction
windProbs <- c(0.1,0.025,0.01,0.01,0.025,0.05,0.16,0.62)
Map.History <- list()                          #Tracking Database Template.
#Tracking Database Template.
tdn <- vector(mode = "numeric", length = 0)    #Records wildfire data
tdy <- vector(mode = "numeric", length = 0)    #Records wildfire data
tdc <- vector(mode = "numeric", length = 0)    #Records wildfire data
tda <- vector(mode = "numeric", length = 0)    #Records wildfire data
tdt <- vector(mode = "numeric", length = 0)    #Records wildfire data
#Combine fuelbed shift lists. Makes selecting between them more efficient (i.e. no if/then
#statments needed to select an object)
D.List <- cbind(T1E.List, T2E.List, D1E.List, D2E.List)
#This will be used to log run times for disturbance loops.
#e.summary <- data.frame()
####################################################################################
####################################################################################
#STEP 09: Generate functions.
#This function (grabbed from the r-help site) is the same as the sample()
#function except if the length of x is one it will just use that number rather than
#sample from 1:x.
resample <- function(x, size, ...)
if(length(x) <= 1) { if(!missing(size) && size == 0) x[FALSE] else x
} else sample(x, size, ...)
#This function provides the location of all pixels surrounding pixels in stand[sn]
sn.seeker <- function(x,y)
{
v1 <- s.map
v2 <- tesn
v3 <- which(v1 %in% v2)
matrix(data = v3, nrow = length(x), ncol = length(v3), byrow = T) + x + y
}
#This function shaves off pixels locations generated by the seeker function
#that have "spilled out" from the top or bottom of s.map.
sn.limit <- function(x,y)
{
m1 <- l.map[rows,which(array(s.map %in% tesn, dim =c(rows,cols)),arr.ind=TRUE)[,2]]
m1a <- matrix(data = m1, nrow = length(x), ncol = length(m1), byrow = T) + x
m2 <- l.map[1,which(array(s.map %in% tesn, dim = c(rows, cols)), arr.ind=TRUE)[,2]]
m2a <- matrix(data = m2, nrow = length(x), ncol = length(m2), byrow = T) + x
m3a <- matrix(data =  rep(y >= 0, length(m2)), nrow = length(x), ncol = length(m2), byrow = F)
ifelse(m3a == T, m1a, m2a)
}
####################################################################################
####################################################################################
#STEP 10: Fire Regime Simulation for Eglin (excludes buffer zone).
#Since the buffer zone fire regime is determined by the eglin fire regime just use
#the Eglin fire regime to drive flammability of fuels.
sim.years <- 10000#1000 year run.
annual.ff <- vector(length = sim.years, mode = 'numeric')
annual.ab <- vector(length = sim.years, mode = 'numeric')
fire.area <- vector(length = sim.years, mode = 'numeric')
for(i in 1:sim.years)
{
p.fino <- round(rpois(1,FF.e),0)
p.fiar <- round(rlnorm(p.fino,Mu.e,Sigma.e),0)
p.fiar <- p.fiar[p.fiar > 0]
p.fino <- length(p.fiar)
annual.ff[i] <- p.fino
annual.ab[i] <- sum(p.fiar)
fire.area <- c(fire.area, p.fiar)
}
max.fire <- min(max(fire.area),Truncate.Area[1])
area.dist <- seq(length = 3000, from = 1, to = max.fire/MapRes)
dist.curve <- mapply(function(y) 1-exp(-1*((y/c.scale)^c.shape)),
seq(length = 3000, from = (1/max.fire), to = 1))
scale.factor <- mapply(function(x) exp(-1*((x/c.scale)^c.shape)),
seq(length = 3000, from = (1/max.fire), to = 1))
#asymptote of curve on x axis (where 0 represents 0 pixels
#burned and 1 represents anything greater than value in windThresholdSize)
#is roughly at this value
asymptote <- 0.5
#Specify relationship between the ratio of current-to-max fire size and
#weibull shape/scale parameter (1-6; a value of 1 will generate mostly
#low windspeeds while a value of 6 will generate average windspeeds of ~12 mph)
fire.ratio <- round(seq(length = 1001, from = 0, to = 1),3)
assoc.wsp <- mapply(function(y) 1-exp(-1*((y/asymptote)^3)),
seq(length = 1001, from = 0, to = 1))
assoc.wsp <- (assoc.wsp*5)+1
####################################################################################
####################################################################################
#STEP 11: Create vectors that list which fuelbeds are eligible for treatment.
#Determine available fuelbeds:
#For thinning treatments
avfb_thin <- fbls[ttxm[,4] == 2]
#For herbicide treatments
avfb_herb <- fbls[ttxm[,5] == 2]
#For prescribed fire treatments
avfb_fire <- fbls[ttxm[,6] == 2]
####################################################################################
####################################################################################
#STEP 12: Update mFRI list and then create a mFRI format that can be updated.
#Update -- the mFRI list needs to be updated because the mFRI data layer was not
#used to inform the generation of all fuelbeds. For instance, small ponds are included
#in polygons representing frequently burned areas but themselves do not burn. This instance
#does not cause a problem because in the look-up tables open water has a mFRI range of
#0-32 and the updating loop at the end of FDM will not consider these "stands". However
#there are thousands of forested stands of unburnable fuels with a long mFRI range.
#For instance sand pine, riparian forests, and young plantations that may be included
#in a short fire return interval polygon but do not burn. These stands present a
#problem because the fire regime updating loop at the end of FDM will flag these stands
#as being outside of their mFRI but the look-up table will maintain the fuelbed (as it should)
#This is a problem because it is a large time burden on FDM run times. To fix this two things should
#happen. First before the loops initiate (i.e. right here) the mFRI list needs to be updated
#to reflect the actual mFRI likely for the stand, not what is shown by the generalized
#mFRI layer (as listed is mfri.List). Second the lookup tables must have alternatives
#for fuelbeds with low-medium to medium probability of burning or they will build up
#over the course of an FDM run as out of compliance with their mFRI range and bog down
#the model.
#This updates the mFRI list so all stands have the correct mFRI given
#their fuelbed. This mostly corrects short mFRIs in non-burnable/low probability burn fuelbeds.
#See above paragraph for more information.
mfri.List_v2 <- mapply(function(y)
{
ifelse(any(mfri.List[y] < d.post$mfri_start[d.post$fuelbed == Fuelbed.List[y]],
mfri.List[y] > d.post$mfri_end[d.post$fuelbed == Fuelbed.List[y]]) == T,
resample(seq(d.post$mfri_start[d.post$fuelbed == Fuelbed.List[y]],
d.post$mfri_end[d.post$fuelbed == Fuelbed.List[y]], 1), 1),
mfri.List[y])
}, 1:length(mfri.List))
#Replace old (and incorrect) mfri.List with new one.
mfri.List <- mfri.List_v2
matcols <- 30
mfri.Matrix <- matrix(data = 0, nrow = length(mfri.List), ncol = matcols)
for(i in 1:length(mfri.List))
{
if(mfri.List[i] == -9999)
{
mfri.Matrix[i,] <- rep(-9999,matcols)
} else
{
temp_mfri <- c(rep(1,ifelse(mfri.List[i] == 32,0,round(matcols/mfri.List[i],0))),
rep(0,ifelse(mfri.List[i] == 32,30,(matcols-round(matcols/mfri.List[i],0)))))
mfri.Matrix[i,] <- sample(temp_mfri, length(temp_mfri))
#mfri.Matrix[i,] <- resample(c(rep(0,(mfri.List[i]-1)),1),
#                           matcols,
#                           prob = rep((1/mfri.List[i]),mfri.List[i]), replace = T)
##Made these changes to the code on 10/19/2015. The new code ensures
#that the list of fires reflects the actual mFRI value in mfri.List whereas this
#old version was based on probability and could produce different values that could
#result in a dramatically different mFRI if there where 2 rather than 1 fire.
}
}
#Create a time since last fire (TSLF) list for burn blocks
#Create a new matrix that shows cumulative fires over the thirty year fire history you created
#in mfri.Matrix
cum.TSLF <- matrix(data = rep(0, (length(mfri.Matrix[,1]) * length(mfri.Matrix[1,]))),
nrow = length(mfri.Matrix[,1]), ncol = length(mfri.Matrix[1,]), byrow = FALSE)
for(i in 1:length(mfri.Matrix[,1]))
{
for(h in 1:length(mfri.Matrix[1,]))
{
cum.TSLF[i,h] <- sum(mfri.Matrix[i,1:h])
}
}
#Use the cumulative number of fires and mfri.Matrix to identify tslf (elements where
#both mfri.Matrix and cum.TSLF == 1)
#This function creates a matrix that only has a one for the most recent year there was
#a fire.
x.tslf <- ifelse(mfri.Matrix == 1 & cum.TSLF == 1,1,0)
#This function creates a vector where each element lists the TSLF in years.
x2.tslf <- mapply(function(y) ifelse(length(which(x.tslf[y,] == 1)) == 0,
31, which(x.tslf[y,] == 1)),
1:length(x.tslf[,1]))
hist(x2.tslf, breaks = 31)
#Second step is to list the stand numbers in each burn unit.
#unit.stands <- list()
for(i in 1:length(b.unit$unit))
{
unit.stands[[i]] <- sort(unique(s.map[b.map == b.unit$unit[i]]))
}
#Next step is to caclulate percentage of each burn unit in each tslf class (1:31 years)
unit.TSLF <- matrix(data = rep(0, (length(b.unit$unit) * (length(mfri.Matrix[1,]) + 1))),
nrow = length(b.unit$unit), ncol = (length(mfri.Matrix[1,]) + 1), byrow = FALSE)
for(i in 1:(length(mfri.Matrix[1,]) + 1))
{
for(h in 1:length(b.unit$unit))
{
unit.TSLF[h,i] <- (sum(Area.List[Stand.List %in%
Stand.List[x2.tslf == i & MU.List == b.unit$unit[h]]])/
sum(Area.List[Stand.List %in% unit.stands[[h]]]))
}
}
#Find peaks in histogram with shortest TSLF. Use an itertive process that slowly
#decreases the minimum area required to qualify as a peak
#Go from 25%, to 0% in increments of 5%.
TSLFxUnits <- rep(0,length(b.unit$unit))
increments <- c(0.25, 0.20, 0.15, 0.10, 0.05, 0.01,0)
for(h in 1:length(increments))
{
for(i in 1:length(b.unit$unit))
{
if(TSLFxUnits[i] == 0)
{
TSLFxUnits[i] <- ifelse(length(which(unit.TSLF[i,] > increments[h])) == 0,
0, min(which(unit.TSLF[i,] > increments[h])))
} else
{
TSLFxUnits[i] <- TSLFxUnits[i]
}
}
}
#Create new table that lists all stands.
write.table(mfri.List, file = paste("sef_mfriList_v2_",
rows,"x",cols,".txt",sep = ""),
append = FALSE, quote = TRUE, sep = ",", eol = "\n", na = "NA",
dec = ".", row.names = TRUE,col.names = NA, qmethod =
c("escape", "double"))#
#Create new table that lists all stands.
write.table(mfri.Matrix, file = paste("sef_mfriMatrix_v2_",
rows,"x",cols,".txt",sep = ""),
append = FALSE, quote = TRUE, sep = ",", eol = "\n", na = "NA",
dec = ".", row.names = TRUE,col.names = NA, qmethod =
c("escape", "double"))#
#Create new table that lists all stands.
write.table(TSLFxUnits, file = paste(
"sef_TSLF.List_v2_",rows,"x",cols,".txt",
sep = ""), append = FALSE, quote = TRUE, sep = ",", eol = "\n", na = "NA",
dec = ".", row.names = TRUE,col.names = NA, qmethod =
c("escape", "double"))#
