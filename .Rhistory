initial.new.cells <- resample(avlo,(a.bun - length(ocod)))
fual <- f.map[match(initial.new.cells, l.map)]
ss.n <- length(fual)
ss <- rbinom(ss.n, 1,  fuelbed_lut$probability_of_ignition[match(fual, fuelbed_lut$fuelbed)])
new.cells <- initial.new.cells[ss == 1]
s.map[new.cells] <- s.map[new.cells]*tesn_t
tesn <- unique(s.map[s.map < 0 & s.map > NoData.Unit])
fual10 <- s.profile[match(f.map[l.map %in% new.cells], fuelbed_lut$fuelbed)]
sProb <- fuelbed_lut$probability_of_ignition[match(f.map[l.map %in% new.cells], fuelbed_lut$fuelbed)]
crownProb <- (fual10 - sProb)
crownProb[crownProb < 0] <- 0
initial.cells.with.crown.fire <- rbinom(length(new.cells),1,crownProb)
spread.type <- 11
} else#------------------------------------------------D-TRUE
{#---------------------------------------------------D-FALSE
initial.new.cells <- resample(avlo,(desa - (dema + length(ocod))))
fual <- f.map[match(initial.new.cells, l.map)]
ss.n <- length(fual)
ss <- rbinom(ss.n, 1,  fuelbed_lut$probability_of_ignition[match(fual, fuelbed_lut$fuelbed)])
new.cells <- initial.new.cells[ss == 1]
s.map[new.cells] <- s.map[new.cells]*tesn_t
tesn <- unique(s.map[s.map < 0 & s.map > NoData.Unit])
fual10 <- s.profile[match(f.map[l.map %in% new.cells], fuelbed_lut$fuelbed)]
sProb <- fuelbed_lut$probability_of_ignition[match(f.map[l.map %in% new.cells], fuelbed_lut$fuelbed)]
crownProb <- (fual10 - sProb)
crownProb[crownProb < 0] <- 0
initial.cells.with.crown.fire <- rbinom(length(new.cells),1,crownProb)
}#-------------------------------------------------D-FALSE
}#-------------------------------------------------------C-FALSE
}#-------------------------------------------------------------A-FALSE
osnd <- c(osnd, s.map[new.cells]) #tracks stand numbers involved in disturbance.
ocod <- c(ocod, new.cells) #tracks coordinates involved in disturbance.
ocod_crown <- c(ocod_crown, new.cells[initial.cells.with.crown.fire == 1])
#Stop loop if growth rate slows below cutoff rate
treatment.growth <- (length(new.cells)/a.bun)*100
if(treatment.growth > cutoff.growth.rate)
{#11.4.1----------------------------------------------------------------------
d <- d#placeholder
} else#11.4.1-----------------------------------------------------------------
{#11.4.2----------------------------------------------------------------------
breaks <- 1142
break
}#11.4.2----------------------------------------------------------------------
} else #11.2.1 ----------------------------------------------------------------------
{#11.2.2
#Fire has burned out and must be reassigned to a new area. Use spread.type = 0 to
#direct loop 9 into section that will locate anew scd
spread.type <- 0
breaks <- 1122
break
} #11.2.2 ---------------------------------------------------------------------------
} else #11.1.1 ----------------------------------------------------------------------
{ #11.1.2 ---------------------------------------------------------------------------
breaks <- 1112
break
} #11.1.2 ---------------------------------------------------------------------------
if(spread.type == 11)
{#11.3.1
#Save units that where burned so far.
burned.units <- c(burned.units, f.bun)
breaks < - 1131
break
} else #11.3.1
{#11.3.2
breaks <- 1132
}#11.3.2
} #11.0.0 ---------------------------------------------------------------------------
expansions_loop8 <- c(expansions_loop8, rep(2,h))#tracks expansions
}#9.7.2 (RX FIRE LOOP)--------------------------------------------------------------
#Reset tesn, it should be -1 for FDM, except in loop 10 where it must include multiple
#values to support the burn out function.
tesn <- -1#temporary stand number.
osnd <- abs(osnd)
#Find affected stands that affected by crown fire.
pos_crown <- which(is.na(match(ocod, ocod_crown)) == F)
osnd_crown <- osnd[pos_crown]
#Pare new stand and corresponding location objects to remove stands burned in crown fire.
if(length(osnd_crown) == 0)
{
osnd_surface <- osnd
ocod_surface <- ocod
} else
{
osnd_surface <- osnd[-pos_crown]
ocod_surface <- ocod[-pos_crown]
}
neef_surface <- vector()
neef_crown <- vector()
#SURFACE FIRE>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
if(length(osnd_surface) > 0)
{
#Show fuelbeds associated with stands affected by fire
fb_f12_surface <- Fuelbed.List[Stand.List %in% osnd_surface]
#List corresponding stand numbers.
osno_surface <- Stand.List[Stand.List %in% osnd_surface]
#Expand fuelbeds to include each occurence of stand number in osnd
effb_surface <- fb_f12_surface[match(osnd_surface, osno_surface)]
#Calculate number of new stands
noef_surface <- length(osno_surface)
#Determine new stand numbers for treatment[b], block[cc].
if(noef_surface == 0)
{
neef_surface <- 0
} else
{
neef_surface <- seq((mudn + 1), (mudn + noef_surface), 1)
}
#Map new stands
ods <- data.frame(ocod_surface, osnd_surface)
ods <- ods[order(ods$ocod_surface),]
v.neef_surface <- neef_surface[match(ods$osnd_surface, osno_surface)]
s.map[l.map %in% ods$ocod_surface] <- v.neef_surface
#
osno_all <- osno_surface
} else
{
osno_surface <- vector()
osno_all <- osno_surface
v.neef_surface <- vector()
}
#CROWN FIRE>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
if(length(osnd_crown) > 0)
{
#Show fuelbeds associated with stands affected by fire
fb_f12_crown <- Fuelbed.List[Stand.List %in% osnd_crown]
#List corresponding stand numbers.
osno_crown <- Stand.List[Stand.List %in% osnd_crown]
#Expand fuelbeds to include each occurence of stand number in osnd
effb_crown <- fb_f12_crown[match(osnd_crown, osno_crown)]
#Crown Fire
#Calculate number of new stands
noef_crown <- length(osno_crown)
#Determine new stand numbers for treatment[b], block[cc].
if(noef_crown == 0)
{
neef_crown <- 0
} else
{
neef_crown <- seq(ifelse(length(neef_surface) == 0, mudn, max(neef_surface) + 1),
(ifelse(length(neef_surface) == 0, mudn + noef_crown, max(neef_surface) + noef_crown)), 1)
}
#Map new stands
odc <- data.frame(ocod_crown, osnd_crown)
odc <- odc[order(odc$ocod_crown),]
v.neef_crown <- neef_crown[match(odc$osnd_crown, osno_crown)]
s.map[l.map %in% odc$ocod_crown] <- v.neef_crown
#
osno_all <- c(osno_all, osno_crown)
} else
{
osno_crown <- vector()
osno_all <- c(osno_all, osno_crown)
v.neef_crown <- vector()
}
if(sum(neef_surface,neef_crown) == 0)
{
loopF.NewStand <- loopF.NewStand
loopF.Area <- loopF.Area
} else
{
loopF.NewStand <- c(loopF.NewStand,neef_surface, neef_crown)
l.neef <- rep(1,length(v.neef_surface) + length(v.neef_crown))
s.neef_a <- summarize(l.neef, c(v.neef_surface, v.neef_crown), sum)
s.neef <- as.vector(s.neef_a[,2])
loopF.Area <- c(loopF.Area, s.neef)
}
loopF.ReplacedStand <- c(loopF.ReplacedStand, osno_all)
loopF.E_no <- c(loopF.E_no, rep(e, length(osno_all)))
loopF.F_no <- c(loopF.F_no, rep(f, length(osno_all)))
loopF.G_H_no <- c(loopF.G_H_no, rep(length(expansions_loop8), length(osno_all)))
loopF.fireType <- c(loopF.fireType,
c(rep(1, length(osno_surface)), rep(2, length(osno_crown))))
##############################################################################
##############################################################################
##############################################################################
#ONLY TO DIAGNOSE ERRORS FROM MODEL RUN 101                                 #
#DRAG ON TIME, REMOVE AFTER ERRORS DIAGNOSED                                #
if(length(unique(loopF.NewStand)) != length(loopF.NewStand) |
length(loopF.ReplacedStand) != length(loopF.NewStand) |
length(v.neef_surface) + length(v.neef_crown) != length(s.map[l.map %in% c(ocod_surface,ocod_crown)]))
{
r101 <- 2
break
} else
{
r101 <- ifelse(any(s.map < 0 & s.map > -9999),22,0)
}
#TEMPOARY -- FORCES FDM TO CRASH IF -1 IS ASSSIGNED TO S.MAP
if(length(s.map[s.map < 0 & s.map > -9999]) > 0)
{
aaa <- data.frame(B = loopB.new_stand, F = loopF.NewStand)
} else
{
f <- f
}
#TEMPOARY -- FORCES FDM TO CRASH IF -1 IS ASSSIGNED TO S.MAP
} else #9.4.1 ----------------------------------------------------------------------
{ #9.4.2 ---------------------------------------------------------------------------
} #9.4.2 ---------------------------------------------------------------------------
} else #9.3.1 ----------------------------------------------------------------------
{ #9.3.2 ---------------------------------------------------------------------------
r101 <- 8
break
} #9.3.2 ---------------------------------------------------------------------------
} else #9.1.1 ----------------------------------------------------------------------
{ #9.1.2 ---------------------------------------------------------------------------
break
} #9.1.2 ---------------------------------------------------------------------------
##############################################################################
##############################################################################
##############################################################################
} #9.0.0 ---------------------------------------------------------------------------
#Log new stand numbers and associated disturbances when they have been added to
#s.map.
loopE.NewStand <- c(loopE.NewStand,loopF.NewStand)
loopE.Area <- c(loopE.Area,loopF.Area)
loopE.ReplacedStand <- c(loopE.ReplacedStand,loopF.ReplacedStand)
loopE.E_no <- c(loopE.E_no, loopF.E_no)
loopE.F_no <- c(loopE.F_no, loopF.F_no)
loopE.G_H_no <- c(loopE.G_H_no, loopF.G_H_no)
loopE.fireType <- c(loopE.fireType, loopF.fireType)
loopE <- data.frame(NewStand = loopE.NewStand,
ReplacedStand = loopE.ReplacedStand,
Area = loopE.Area,
Fire = loopE.fireType,
E_no = loopE.E_no,
F_no = loopE.F_no,
G_H_no = loopE.G_H_no)
loopE <- loopE[order(loopE$ReplacedStand),]
} else #8.1.1 ----------------------------------------------------------------------
{ #8.1.2 ---------------------------------------------------------------------------
#Log new stand numbers and associated disturbance when they have been added to
#s.map.
loopE.NewStand <- c(loopE.NewStand,loopF.NewStand)
loopE.Area <- c(loopE.Area,loopF.Area)
loopE.ReplacedStand <- c(loopE.ReplacedStand,loopF.ReplacedStand)
loopE.E_no <- c(loopE.E_no, loopF.E_no)
loopE.F_no <- c(loopE.F_no, loopF.F_no)
loopE.G_H_no <- c(loopE.G_H_no, loopF.G_H_no)
loopE.fireType <- c(loopE.fireType, loopF.fireType)
loopE <- data.frame(NewStand = loopE.NewStand,
ReplacedStand = loopE.ReplacedStand,
Area = loopE.Area,
Fire = loopE.fireType,
E_no = loopE.E_no,
F_no = loopE.F_no,
G_H_no = loopE.G_H_no)
loopE <- loopE[order(loopE$ReplacedStand),]
break.message <- "No Flammable Fuel"
} #8.1.2 ---------------------------------------------------------------------------
#Print out run status
run_status(row.code, t.code, a, b, cc, e, f, tdn, tdy, tdc)
##############################################################################
##############################################################################
##############################################################################
#ONLY TO DIAGNOSE ERRORS FROM MODEL RUN 101                                  #
#DRAG ON TIME, REMOVE AFTER ERRORS DIAGNOSED                                 #
if(r101 > 0)                                                                 #
{                                                                            #
r101 <- r101
break
} else                                                                       #
{                                                                            #
r101 <- r101
}                                                                            #
#                                                                            #
} #8.0.0 ------------------------------------------------------------------#
}                                                                            #
#
if(r101 > 0)                                                                 #
{                                                                            #
r101 <- r101
break
} else                                                                       #
{                                                                            #
r101 <- r101
}                                                                            #
##############################################################################
##############################################################################
##############################################################################
length(loopE.NewStand) > 0
#Update mfri List (not done after loop 2, so even if there are no wildfires
#we still need to account for new treatments)
mfri.List <- apply(mfri.Matrix,1,sum)
mfri.List <- round(30/mfri.List,0)
mfri.List <- ifelse(mfri.List == Inf, 32, mfri.List)
#Update files based on time-since-last-treatment>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
#Show max time-since-last-treatment before state transitions for each fuelbed
max_tslt <- fuelbed_lut$max_tslt[fuelbed_lut$fuelbed %in% tslt.Fuelbeds]
#List each of the fuelbeds corresponding with tslt object above
max_tslt_fb <- fuelbed_lut$fuelbed[fuelbed_lut$fuelbed %in% tslt.Fuelbeds]
#Expand to the max tslt object for each row in tslt.List
max_tslt_x_stand <- max_tslt[match(tslt.Fuelbeds, max_tslt_fb)]
#Crash model is Fuelbed.List turned into a list()
if(length(max_tslt_x_stand) != length(tslt.List))
{
r101 <- "inconcistency in tslt tracking"
break
} else
{
r101 <- r101
}
#List stand numbers for stands that will transition.
replace_stands <- tslt.Stands[tslt.List > max_tslt_x_stand]
#List fuelbeds of stands that will transition.
replace_fbs <- tslt.Fuelbeds[tslt.List > max_tslt_x_stand]
#List unique current fuelbeds for stands that will transition.
old_fbs <- fuelbed_lut$fuelbed[fuelbed_lut$fuelbed %in% replace_fbs]
#List unique new fuelbeds for stands that will transition.
new_fbs <- fuelbed_lut$post_1[fuelbed_lut$fuelbed %in% replace_fbs]
new_fbs
if(length(new_fbs) == 0)
{#>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>FALSE
#Order tslt objects by stand number before you apply it to .List objects
tslt.List <- tslt.List[order(tslt.Stands)]
tslt.Fuelbeds <- tslt.Fuelbeds[order(tslt.Stands)]
tslt.Stands <- sort(tslt.Stands)
} else#>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>FALSE
{#>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>TRUE
#List unique new lower mFRI limit fuelbeds for stands that will transition.
#If not specified as a vector this object will become a list when there are
#no new fuelbeds to update and FDM will crash.
new_lower <- vector()
new_lower <- mapply(function(y)
{
fuelbed_lut$mfri_shortens[fuelbed_lut$fuelbed == y]
},
new_fbs)
#List unique new upper mFRI limit fuelbeds for stands that will transition.
new_upper_1 <- vector()
new_upper_1 <- mapply(function(y)
{
fuelbed_lut$mfri_lengthens_1[fuelbed_lut$fuelbed == y]
},
new_fbs)
new_upper_2 <- vector()
new_upper_2 <- mapply(function(y)
{
fuelbed_lut$mfri_lengthens_2[fuelbed_lut$fuelbed == y]
},
new_fbs)
#Expand new unique fuelbeds to the number of stands that will transition.
new_fbs_x_stand <- new_fbs[match(replace_fbs, old_fbs)]
new_lower_x_stand <- new_lower[match(replace_fbs, old_fbs)]
new_upper_1_x_stand <- new_upper_1[match(replace_fbs, old_fbs)]
new_upper_2_x_stand <- new_upper_2[match(replace_fbs, old_fbs)]
new_upper_x_stand <- apply(matrix(data = c(new_upper_1_x_stand, new_upper_2_x_stand),
length(new_upper_1_x_stand), 2), 1, sample,
size = 1)
#Replace current fuelbeds with new ones in cases where tslt exceeds limit for
#state.
tslt.Fuelbeds[tslt.Stands %in% replace_stands] <- new_fbs_x_stand
#Order tslt objects by stand number before you apply it to .List objects
tslt.List <- tslt.List[order(tslt.Stands)]
tslt.Fuelbeds <- tslt.Fuelbeds[order(tslt.Stands)]
tslt.Stands <- sort(tslt.Stands)
#Apply changes to f.map and Fuelbed.List
vt.map <- s.map[s.map %in% tslt.Stands]
v.tslt <- tslt.Fuelbeds[match(vt.map, tslt.Stands)]
f.map[s.map %in% tslt.Stands] <- v.tslt
Fuelbed.List[Stand.List %in% tslt.Stands] <- tslt.Fuelbeds
mfri_lower.List[Stand.List %in% replace_stands] <- new_lower_x_stand
mfri_upper.List[Stand.List %in% replace_stands] <- new_upper_x_stand
}#>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>TRUE
#Remove stands that have been overwritten
tslt.List <- tslt.List[!(is.na(match(tslt.Stands, Stand.List[Stand.List %in% tslt.Stands])))]
tslt.Fuelbeds <- tslt.Fuelbeds[!(is.na(match(tslt.Stands, Stand.List[Stand.List %in% tslt.Stands])))]
tslt.Stands <- tslt.Stands[!(is.na(match(tslt.Stands, Stand.List[Stand.List %in% tslt.Stands])))]
#Remove rows where fuelbeds no longer represent a silvicultural treatment
tslt.List <- tslt.List[which(mapply(function(y)
{as.numeric(strsplit(as.character(y), "")[[1]])[4]}
, tslt.Fuelbeds) %in% c(2,3,4,6,7,8) == T)]
tslt.Stands <- tslt.Stands[which(mapply(function(y)
{as.numeric(strsplit(as.character(y), "")[[1]])[4]}
, tslt.Fuelbeds) %in% c(2,3,4,6,7,8) == T)]
tslt.Fuelbeds <- tslt.Fuelbeds[which(mapply(function(y)
{as.numeric(strsplit(as.character(y), "")[[1]])[4]}
, tslt.Fuelbeds) %in% c(2,3,4,6,7,8) == T)]
##############################################################################
##############################################################################
##############################################################################
#ONLY TO DIAGNOSE ERRORS FROM MODEL RUN 101                                 #
#DRAG ON TIME, REMOVE AFTER ERRORS DIAGNOSED                                #
if(any(c(length(Stand.List),
length(Fuelbed.List),
length(mfri.List),
length(MU.List),
length(Area.List),
length(mfri_lower.List),
length(mfri_upper.List),
length(Age.List)) != (length(unique(as.vector(s.map)))-1)) == T)
{
r101 <- 3
break
} else
{
r101 <- ifelse(any(s.map < 0 & s.map > -9999),33,0)
}
##############################################################################
##############################################################################
##############################################################################
#Update fuelbeds based on impacts of changing mean fire return interval.
#Make a copy of the Fuelbed.List
feof <- Fuelbed.List
#Create a parellel list that shows lower bound of mFRI for each stand
mfri_lower <- fuelbed_lut$mfri_lower[match(feof,fuelbed_lut$fuelbed)]
#Create a parellel list that shows upper bound of mFRI for each stand
mfri_upper <- fuelbed_lut$mfri_upper[match(feof,fuelbed_lut$fuelbed)]
#Replace fuelbed with one representing a more frequent fire regime if the mFRI is shorter
#than the lower limit for the current fuelbed.
feof[mfri.List <  mfri_lower] <- mfri_lower.List[mfri.List < mfri_lower]
#Replace fuelbed with one representing a less frequent fire regime if the mFRI is longer
#than the lower limit for the current fuelbed.
feof[mfri.List > mfri_upper] <- mfri_upper.List[mfri.List > mfri_upper]
#Update f.map
#Improved function to update f.map based on mFRI. Former code used a for()
s.SL <- Stand.List[Fuelbed.List != feof]
feof2 <- feof[Fuelbed.List != feof]
vs.map <- s.map[s.map %in% s.SL]
v.feof2 <- feof2[match(vs.map, s.SL)]
f.map[s.map %in% s.SL] <- v.feof2
stands.affected.by.fire.succession <- Stand.List[Fuelbed.List != feof]
Fuelbed.List <- feof
head(feof)
head(Fuelbed.List)
#Pass on error messages and break if necessary
if(r101 == 0)
{
r101 <- r101
} else
{
r101 <- r101
break
}
#Identify potential changes in fuelbeds based on succession pathways.
pmuf <- mapply(function(x) ifelse(
Age.List[x] > fuelbed_lut$succession_max[fuelbed_lut$fuelbed == Fuelbed.List[x]],
ifelse(fuelbed_lut$succession_post_2[fuelbed_lut$fuelbed == Fuelbed.List[x]] > 0,
resample(c(fuelbed_lut$succession_post_1[fuelbed_lut$fuelbed == Fuelbed.List[x]],
fuelbed_lut$succession_post_2[fuelbed_lut$fuelbed == Fuelbed.List[x]]),1),
fuelbed_lut$succession_post_1[fuelbed_lut$fuelbed == Fuelbed.List[x]]),
Fuelbed.List[x]),1:length(Stand.List))
#Update f.map
#Improved function to update f.map based on mFRI. Former code used a for()
s.SL2 <- Stand.List[Fuelbed.List != pmuf]
pmuf2 <- pmuf[Fuelbed.List != pmuf]
vs.map2 <- s.map[s.map %in% s.SL2]
v.pmuf2 <- pmuf2[match(vs.map2, s.SL2)]
f.map[s.map %in% s.SL2] <- v.pmuf2
stands.affected.by.age.succession <- Stand.List[Fuelbed.List != pmuf]
Fuelbed.List[Stand.List %in% s.SL2] <- pmuf2
#update mfri_lower.List and mfri_upper.List based on changes in Fuelbed map from feof and pmuf
#Stand affected by change in mean fire return interval or age.
stands.that.shifted <- sort(unique(c(stands.affected.by.age.succession,
stands.affected.by.fire.succession)))
stands.that.shifted
#Corresponding fuels
fuels.that.shifted_Xstand <- Fuelbed.List[Stand.List %in% stands.that.shifted]
#List of unique fuelbeds
fuels.that.shifted <- sort(unique(fuels.that.shifted_Xstand))
fuels.that.shifted
#List unique new lower mFRI limit fuelbeds for stands that will transition.
shift_lower <- fuelbed_lut$mfri_shortens[fuelbed_lut$fuelbed %in% fuels.that.shifted]
#List unique new upper mFRI limit fuelbeds for stands that will transition.
shift_upper_1 <- fuelbed_lut$mfri_lengthens_1[fuelbed_lut$fuelbed %in% fuels.that.shifted]
shift_upper_2 <- fuelbed_lut$mfri_lengthens_2[fuelbed_lut$fuelbed %in% fuels.that.shifted]
shift_lower_x_stand <- shift_lower[match(fuels.that.shifted_Xstand, fuels.that.shifted)]
shift_upper_1_x_stand <- shift_upper_1[match(fuels.that.shifted_Xstand, fuels.that.shifted)]
shift_upper_2_x_stand <- shift_upper_2[match(fuels.that.shifted_Xstand, fuels.that.shifted)]
shift_upper_x_stand <- apply(matrix(data = c(shift_upper_1_x_stand, shift_upper_2_x_stand),
length(shift_upper_1_x_stand), 2), 1, sample,
size = 1)
mfri_lower.List[Stand.List %in% stands.that.shifted] <- shift_lower_x_stand
mfri_upper.List[Stand.List %in% stands.that.shifted] <- shift_upper_x_stand
shift_lower
shift_upper_1
shift_upper_2
#Update the .tslt objects for any stands affected by changes in age or mFRI
shift.in.tslt_stands <- tslt.Stands[match(stands.that.shifted, tslt.Stands)]
shift.in.tslt_stands <- shift.in.tslt_stands[!is.na(shift.in.tslt_stands) == T]
shift.in.tslt_fuels <- fuels.that.shifted_Xstand[match(shift.in.tslt_stands, stands.that.shifted)]
tslt.Fuelbeds[tslt.Stands %in% shift.in.tslt_stands] <- shift.in.tslt_fuels
#Kill model if any fuelbed numbers are < 0. This means there is an error in the lookup
#table.
if(any(Fuelbed.List < 0) == T | is.list(Fuelbed.List) == T)
{
broken.stands <- Stand.List[Fuelbed.List < 0]
f.orig <- matrix(scan(paste("inputs/sef_fmap_v2_",rows,"x",cols,".txt",
sep = ""),skip = fh.adj),ncol=cols,byrow=T)#16
break
} else
{
#don't break
}
#Create maps for interval years.
if((a %% Interval) == 0)
{
#  #Save Fuelbed Map (f.map).
dt <- Sys.Date()
tm <- format(Sys.time(), format = "%H.%M.%S",
tz = "", usetz = FALSE)
#write.table(s.map, file = paste(output_path, "sef_smap_run_", run, "_",
#                                dt,"_",tm,"_R",rows,"xC",cols,"_Y",a,".txt",sep = ""),
#            append = FALSE, quote = TRUE, sep = " ", eol = "\n", na = "NA",
#            dec = ".", row.names = FALSE,col.names = FALSE, qmethod =
#             c("escape", "double"))#
write.table(f.map, file = paste(output_path, "sef_fmap_run_", run, "_",
dt,"_",tm,"_R",rows,"xC",cols,"_Y",a,".txt",sep = ""),
append = FALSE, quote = TRUE, sep = " ", eol = "\n", na = "NA",
dec = ".", row.names = FALSE,col.names = FALSE, qmethod =
c("escape", "double"))#
}
