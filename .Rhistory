if(length(loopE.NewStand) > 0)
{
a14 <- system.time({
#Object shows fuelbeds associated with each new stand number created by
#disturbances in year[a].
#ufxDa <- mapply(function(x) unique(f.map[s.map == x]), loopE.NewStand)
ufxDa_1 <- Fuelbed.List[Stand.List %in% loopE$ReplacedStand]
usxDa_1 <- Stand.List[Stand.List %in% loopE$ReplacedStand]
ufxDa <- ufxDa_1[match(loopE$ReplacedStand, usxDa_1)]
#Storage for fuelbeds and ages of new stands.
#sfubed <- vector()
#sagesd <- vector()
})#a14
a15 <- system.time({
#Update portion of f.map affected by disturbances for year[a].
#for(i in 1:length(loopE.NewStand))
#{
#Updates f.map.
#f.map[s.map == loopE.NewStand[i]] <- dtxm[,2][fblo[d.post$fuelbed == ufxDa[i]]]
#replaced with dummy code on Oct 20 b/c this code should be for crown fires.
#f.map[s.map == loopE.NewStand[i]] <- d.post$fuelbed[fblo[d.post$fuelbed == ufxDa[i]]]
#Forms a list of the new fuelbeds.
#sfubed[i] <- dtxm[,2][fblo[d.post$fuelbed == ufxDa[i]]]
#replaced with dummy code on Oct 20 b/c this code should be for crown fires.
#sfubed[i] <- d.post$fuelbed[fblo[d.post$fuelbed == ufxDa[i]]]
#Forms a list of the new ages.
#sagesd[i] <- (f.path$start[f.path$pre == dtxm[,2][fblo[
#  d.post$fuelbed == ufxDa[i]]]] - 1)
#replaced with dummy code on Oct 20 b/c this code should be for crown fires.
#sagesd[i] <- Age.List[Stand.List == loopE.ReplacedStand[i]]
#}
#Code below replaces loop, vene though there are more lines it should run way faster.
#Add ufxDa to loopE data frame
loopE <- data.frame(loopE, ufxDa = ufxDa)
#Sort data frame by new stands
loopE <- loopE[order(loopE$NewStand),]#probably unecessary
#seperate out new stands from s.map, lists occurrences of new stands from min to max coords.
vs.map_a15 <- s.map[s.map %in% loopE$NewStand]
#List of row numbers in d.post where fuelbeds need to be updated based on treatment
LL1_a15 <- which(d.post$fuelbed %in% loopE$ufxDa)
#Fuelbeds that may be updated corresponding with row numbers in LL1_a15
FL1_a15 <- d.post$fuelbed[d.post$fuelbed %in% ufxDa]
#row numbers in d.post corresponding with each existing fuelbed in each new stand
LL2_a15 <- LL1_a15[match(loopE$ufxDa, FL1_a15)]
#Use row numbers (LL2) and column numbers (loopB.treat_type) to calculate "coordinate" in t.post
#LL3_a15 <- ((loopE$TreatType - 1) * length(d.post$fuelbed)) + LL2_a15
#Activate when you can differentiate between crown fire and surface fire
#Convert t.post (ttxm is t.post) from a data.frame into a matrix so new fuelbeds can be identified
#by coordinates that corresond with row and column numbers.
#am_ttxm <- as.matrix(ttxm)
#Activate when you can differentiate between crown fire and surface fire
#Idenintify new fuelbed for each new stand.
#newFB_a15 <- am_ttxm[LL3]
#Activate when you can differentiate between crown fire and surface fire
newFB_a15 <- d.post[LL2_a15,1]
#Lists occurrences of new fuelbeds from min to max coords.
v.newFB_a15 <- newFB_a15[match(vs.map_a15, loopE$NewStand)]
#Replace old fuelbeds with new ones in f.map
f.map[s.map %in% loopE$NewStand] <- v.newFB_a15
#List ages associated with each stand that has been affected by treatment
#These will be used to update Age.List but are unchanged since treatments do not
#change overstory age.
newAGE_a15_1 <- Age.List[Stand.List %in% loopE$ReplacedStand]
newAGE_a15 <- newAGE_a15_1[match(loopE$ReplacedStand, usxDa_1)]
#Re-order loopB data frame by old stands because that is the order of ages in newAGE_a7.
loopE <- loopE[order(loopE$ReplacedStand),]
#Add newAGE_a7 to loopB data.frame
loopE <- data.frame(loopE, newAGE_a15 = newAGE_a15)
})#a15
a16 <- system.time({
#List stands that have been altered by disturbances.
ss2 <- loopE.ReplacedStand
standd <- sort(unique(ss2))#there can be duplicates, this will mess up the shortcut in a9
sb <- summarize(loopE.Area,ss2,sum)#sum areas for duplicates.
saread <- as.vector(sb[,2])
smud <- mapply(function(y) MU.List[Stand.List == y], loopE.ReplacedStand)
})#a16
a17 <- system.time({
#Shelve fire history for stands that have been impacted by disturbance
new_mfri_vec <- mapply(function(y) mfri.Matrix[Stand.List == y,], loopE.ReplacedStand)
nmvd <- t(new_mfri_vec)
#Add a fire for stands that were burned in wildfires
nmvd[,30] <- 1
})#a17
a18 <- system.time({
#Improved method removes loop
#sad_a18 <- data.frame(standd = standd, saread = saread)
#sad_a18b <- sad_a18[order(sad_a18$standd),]
#Area.List[Stand.List %in% sad_a18b$standd] <- Area.List[Stand.List %in% sad_a18b$standd] - sad_a18b$saread
#Change stand properties as needed for treatments.
for(i in 1:length(standd))
{
Area.List[Stand.List == standd[i]] <-
Area.List[Stand.List == standd[i]] - saread[i]
}
})#a18
a19 <- system.time({
#Update list to remove any stands that have been overwritten.
Stand.List <- Stand.List[(Area.List == 0) == F]
Fuelbed.List <- Fuelbed.List[(Area.List == 0) == F]
Age.List <- Age.List[(Area.List == 0) == F]
T1E.List <- T1E.List[(Area.List == 0) == F]
T2E.List <- T2E.List[(Area.List == 0) == F]
D1E.List <- D1E.List[(Area.List == 0) == F]
D2E.List <- D2E.List[(Area.List == 0) == F]
Coord.List <- Coord.List[(Area.List == 0) == F]
MU.List <- MU.List[(Area.List == 0) == F]
mfri.Matrix <- mfri.Matrix[(Area.List == 0) == F,]
Area.List <- Area.List[(Area.List == 0) == F]
})#a19
a20 <- system.time({
#Update list to add new stands.
Stand.List <- c(Stand.List, loopE.NewStand)
Fuelbed.List <- c(Fuelbed.List, newFB_a15)
Age.List <- c(Age.List, newAGE_a15)
#List fuelbeds that need to be updated.
pdaFB_a20 <- pda$pre[pda$pre %in% newFB_a15]
#List corresponding updated age restrictions
pdaTH_a20 <- pda$thin[pda$pre %in% newFB_a15]
#List occurences of age restriction for each new stand
v.THIN_a20 <- pdaTH_a20[match(newFB_a15,pdaFB_a20)]
#Update
T1E.List <- c(T1E.List,v.THIN_a20)
#List corresponding updated age restrictions
pdaHE_a20 <- pda$herb[pda$pre %in% newFB_a15]
#List occurences of age restriction for each new stand
v.HERB_a20 <- pdaHE_a20[match(newFB_a15,pdaFB_a20)]
#Update
T2E.List <- c(T2E.List, v.HERB_a20)
#List corresponding updated age restrictions
pdaSF_a20 <- pda$sfire[pda$pre %in% newFB_a15]
#List occurences of age restriction for each new stand
v.SFIRE_a20 <- pdaSF_a20[match(newFB_a15,pdaFB_a20)]
#Update
D1E.List <- c(D1E.List, v.SFIRE_a20)
#List corresponding updated age restrictions
pdaCF_a20 <- pda$cfire[pda$pre %in% newFB_a15]
#List occurences of age restriction for each new stand
v.CFIRE_a20 <- pdaCF_a20[match(newFB_a15,pdaFB_a20)]
#Update
D2E.List <- c(D2E.List, v.CFIRE_a20)
#List new stand occurrences in s.map
vs.map_a20 <- s.map[s.map %in% loopE.NewStand]
#List corresponding coordinates (l.map) for new stand occurrences in s.map
vl.map_a20 <- l.map[s.map %in% loopE.NewStand]
#Use summarize function (w/ min()) to select a single coordinate value for each new stand.
v.Coord_a20a <- summarize(vl.map_a20,vs.map_a20,min)
#Subset coordinates
v.Coord_a20b <- as.vector(v.Coord_a20a[,2])
#Update
Coord.List <- c(Coord.List,v.Coord_a20b)
MU.List <- c(MU.List, smud)
mfri.Matrix <- rbind(mfri.Matrix,nmvd)
mfri.List <- apply(mfri.Matrix,1,sum)
mfri.List <- round(30/mfri.List,0)
mfri.List <- ifelse(mfri.List == Inf, 32, mfri.List)
Area.List <- c(Area.List,loopE.Area)
})#a20
##############################################################################
##############################################################################
##############################################################################
#ONLY TO DIAGNOSE ERRORS FROM MODEL RUN 101                                 #
#DRAG ON TIME, REMOVE AFTER ERRORS DIAGNOSED                                #
if(any(c(length(Stand.List),
length(Fuelbed.List),
length(mfri.List),
length(MU.List),
length(T1E.List),
length(T2E.List),
length(D1E.List),
length(D2E.List),
length(Area.List),
length(Age.List)) != (length(unique(as.vector(s.map)))-1)) == T)
{
r101 <- 3
break
} else
{
r101 <- 0
}
##############################################################################
##############################################################################
##############################################################################
a21 <- system.time({
feof <- mapply(function(x) ifelse(
mfri.List[x] < d.post$mfri_start[d.post$fuelbed == Fuelbed.List[x]],
d.post$more_fire[d.post$fuelbed == Fuelbed.List[x]],
ifelse(
mfri.List[x] > d.post$mfri_end[d.post$fuelbed == Fuelbed.List[x]],
ifelse(d.post$less_fire2[d.post$fuelbed == Fuelbed.List[x]] > 0,
resample(c(d.post$less_fire1[d.post$fuelbed == Fuelbed.List[x]],
d.post$less_fire2[d.post$fuelbed == Fuelbed.List[x]]),1),
d.post$less_fire1[d.post$fuelbed == Fuelbed.List[x]]),
Fuelbed.List[x])),1:length(Stand.List))
#cbind(Stand.List,Fuelbed.List,feof)
})#a21
a22 <- system.time({
#Update f.map
#Improved function to update f.map based on mFRI. Former code used a for()
s.SL <- Stand.List[Fuelbed.List != feof]
feof2 <- feof[Fuelbed.List != feof]
vs.map <- s.map[s.map %in% s.SL]
v.feof2 <- feof2[match(vs.map, s.SL)]
f.map[s.map %in% s.SL] <- v.feof2
Fuelbed.List[Stand.List %in% s.SL] <- feof2
#Update f.map (old code, works on the order of minutes: 500 stands/minute)
#for(i in 1:length(Stand.List))
#  if(Fuelbed.List[i] != feof[i])
#  {
#    f.map[s.map == Stand.List[i]] <- feof[i]
#    Fuelbed.List[i] <- feof[i]
#  }
})#a22
a23 <- system.time({
#Temporary -- run 41
Loop.track[[length(Loop.track) + 1]] <- c(a,b,cc,d,e,f,g)
MU.track[[length(MU.track) + 1]] <- MU.List
mgmtUnit.track[[length(mgmtUnit.track) + 1]] <- loopB.new_mgmtUnit
len <- vector(length = 0, mode = 'numeric')
lea <- vector(length = 0, mode = 'numeric')
ler <- vector(length = 0, mode = 'numeric')
len <- loopE.NewStand
lea <- loopE.Area
ler <- loopE.ReplacedStand
})#a23
#cbind(Stand.List,Fuelbed.List,Area.List)
} else
{
#No new stand numbers, enter a placeholder.
if(length(Disturbance.History) == 0)
{
a24 <- system.time({
Disturbance.History[[(length(Disturbance.History)+1)]] <- "No Data."
names(Disturbance.History)[[length(Disturbance.History)]] <- paste(
"No disturbances this year.", collapse = "")
})#a24
}
}
#Post run step 3>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
#Update files based on succession
#Identify potential changes in fuelbeds based on succession pathways.
a25 <- system.time({
pmuf <- mapply(function(x) ifelse(
Age.List[x] > f.path$end[f.path$pre == Fuelbed.List[x]],
ifelse(f.path$post_2[f.path$pre == Fuelbed.List[x]] > 0,
resample(c(f.path$post_1[f.path$pre == Fuelbed.List[x]],
f.path$post_2[f.path$pre == Fuelbed.List[x]]),1),
f.path$post_1[f.path$pre == Fuelbed.List[x]]),
Fuelbed.List[x]),1:length(Stand.List))
#cbind(Stand.List,Fuelbed.List,pmuf)
})#a25
a26 <- system.time({
#Update f.map
#Update f.map
#Improved function to update f.map based on mFRI. Former code used a for()
s.SL2 <- Stand.List[Fuelbed.List != pmuf]
pmuf2 <- pmuf[Fuelbed.List != pmuf]
vs.map2 <- s.map[s.map %in% s.SL2]
v.pmuf2 <- pmuf2[match(vs.map2, s.SL2)]
f.map[s.map %in% s.SL2] <- v.pmuf2
Fuelbed.List[Stand.List %in% s.SL2] <- pmuf2
#for(i in 1:length(Stand.List))
#  if(Fuelbed.List[i] != pmuf[i])
#  {
#    f.map[s.map == Stand.List[i]] <- pmuf[i]
#    Fuelbed.List[i] <- pmuf[i]
#  }
})#a26
a27 <- system.time({
#Update D.List
D.List <- cbind(T1E.List, T2E.List, D1E.List, D2E.List)
})#a27
a28 <- system.time({
#})#TESTING
#Save run data.
dt <- Sys.Date()
tm <- format(Sys.time(), format = "%H.%M.%S",
tz = "", usetz = FALSE)
write.table(e.summary, file = paste("C:\\usfs_sef_outputs_FDM\\run_", run,"\\sef_run", run,"_",
dt,"_",tm,"_year_",a,".txt",sep = ""),
append = FALSE, quote = TRUE, sep = " ", eol = "\n", na = "NA",
dec = ".", row.names = FALSE,col.names = TRUE, qmethod =
c("escape", "double"))#
})#a28
a29 <- system.time({
#Create maps for interval years.
#if((a %% Interval) == 0)
#{
#  #Save Fuelbed Map (f.map).
dt <- Sys.Date()
tm <- format(Sys.time(), format = "%H.%M.%S",
tz = "", usetz = FALSE)
write.table(s.map, file = paste("C:\\usfs_sef_outputs_FDM\\run_", run,"maps\\sef_smap_",
dt,"_",tm,"_R",rows,"xC",cols,"_Y",a,".txt",sep = ""),
append = FALSE, quote = TRUE, sep = " ", eol = "\n", na = "NA",
dec = ".", row.names = FALSE,col.names = FALSE, qmethod =
c("escape", "double"))#
write.table(f.map, file = paste("C:\\usfs_sef_outputs_FDM\\run_", run,"maps\\sef_fmap_",
dt,"_",tm,"_R",rows,"xC",cols,"_Y",a,".txt",sep = ""),
append = FALSE, quote = TRUE, sep = " ", eol = "\n", na = "NA",
dec = ".", row.names = FALSE,col.names = FALSE, qmethod =
c("escape", "double"))#
#}
#Log treatment and disturbance mapping data for year[a].
Map.History[[a]] <- c(Treatment.History,Disturbance.History)
names(Map.History)[[a]] <- paste("Year", a,":", collapse = "")
})#a29
aa1[length(aa1) + 1] <- a1[3]
aa2[length(aa2) + 1] <- a2[3]
aa3[length(aa3) + 1] <- a3[3]
aa4[length(aa4) + 1] <- a4[3]
aa5[length(aa5) + 1] <- a5[3]
aa6[length(aa6) + 1] <- a6[3]
aa7[length(aa7) + 1] <- a7[3]
aa8[length(aa8) + 1] <- a8[3]
aa9[length(aa9) + 1] <- a9[3]
aa10[length(aa10) + 1] <- a10[3]
aa11[length(aa11) + 1] <- a11[3]
aa12[length(aa12) + 1] <- a12[3]
aa13[length(aa13) + 1] <- a13[3]
aa14[length(aa14) + 1] <- a14[3]
aa15[length(aa15) + 1] <- a15[3]
aa16[length(aa16) + 1] <- a16[3]
aa17[length(aa17) + 1] <- a17[3]
aa18[length(aa18) + 1] <- a18[3]
aa19[length(aa19) + 1] <- a19[3]
aa20[length(aa20) + 1] <- a20[3]
aa21[length(aa21) + 1] <- a21[3]
aa22[length(aa22) + 1] <- a22[3]
aa23[length(aa23) + 1] <- a23[3]
aa24[length(aa24) + 1] <- a24[3]
aa25[length(aa25) + 1] <- a25[3]
aa26[length(aa26) + 1] <- a26[3]
aa27[length(aa27) + 1] <- a27[3]
aa28[length(aa28) + 1] <- a28[3]
aa29[length(aa29) + 1] <- a29[3]
} #1.0.0 ---------------------------------------------------------------------------
####################################################################################
####################################################################################
#Purpose of this script is to determine the burn priority and supression type
#for each burn block
####################################################################################
####################################################################################
####################################################################################
####################################################################################
#Open burn block map.
b.map <- matrix(scan(paste("c:\\usfs_sef_data_ascii\\sef_bmap_",rows,"x",cols,".txt",
sep = ""),skip = bh.adj),ncol=cols,byrow=T)#18
#Open longleaf core conservation area map.
cca.map <- matrix(scan(paste("c:\\usfs_sef_data_ascii\\sef_cca_map_",rows,"x",cols,".txt",
sep = ""),skip = bh.adj),ncol=cols,byrow=T)#18
#Open burn annually/no suppression areas map.
bansa.map <- matrix(scan(paste("c:\\usfs_sef_data_ascii\\sef_bansa_map_",rows,"x",cols,".txt",
sep = ""),skip = bh.adj),ncol=cols,byrow=T)#18
#Open mist (no plow lines) map.
mist.map <- matrix(scan(paste("c:\\usfs_sef_data_ascii\\sef_mist_map_",rows,"x",cols,".txt",
sep = ""),skip = bh.adj),ncol=cols,byrow=T)#18
#Open no suppression areas map.
ns.map <- matrix(scan(paste("c:\\usfs_sef_data_ascii\\sef_ns_map_",rows,"x",cols,".txt",
sep = ""),skip = bh.adj),ncol=cols,byrow=T)#18
#Open restricted suppression areas map.
rs.map <- matrix(scan(paste("c:\\usfs_sef_data_ascii\\sef_rs_map_",rows,"x",cols,".txt",
sep = ""),skip = bh.adj),ncol=cols,byrow=T)#18
#Open eglin test areas map.
eta.map <- matrix(scan(paste("c:\\usfs_sef_data_ascii\\sef_eta_map_",rows,"x",cols,".txt",
sep = ""),skip = bh.adj),ncol=cols,byrow=T)#18
length(bansa.map[bansa.map == 2])
sort(unique(bansa.map))
sort(unique(as.vector(bansa.map)))
length(bansa.map[bansa.map == 20])
#List of burn blocks
BB <- sort(unique(as.vector(b.map)))
BBL <- length(BB)
#Create vectors that will store pixel counts for each burn block
ta <- vector(length = BBL, mode = 'numeric')#total area
cca <- vector(length = BBL, mode = 'numeric')#core conservation area
bansa <- vector(length = BBL, mode = 'numeric')#burn annually no suppression
mist <- vector(length = BBL, mode = 'numeric')#MIST (no plow lines)
ns <- vector(length = BBL, mode = 'numeric')#no suppression
rs <- vector(length = BBL, mode = 'numeric')#restricted suppression
eta <- vector(length = BBL, mode = 'numeric')#eglin test area
BBL
BB
#Calculate area for each management option for each burn block
for(i in 1:BBL)
{
ta[i] <- length(b.map[b.map == BB[i]])
cca[i] <- length(b.map[b.map == BB[i] & cca.map == 2])
bansa[i] <- length(b.map[b.map == BB[i] & bansa.map == 20])
mist[i] <- length(b.map[b.map == BB[i] & mist.map == 200])
ns[i] <- length(b.map[b.map == BB[i] & ns.map == 2000])
rs[i] <- length(b.map[b.map == BB[i] & rs.map == 20000])
eta[i] <- length(b.map[b.map == BB[i] & eta.map == 200000])
}
cc <- data.frame(BurnBlock = BB, Area = ta, CCA = round((cca/ta)*100,0),
MIST = round((mist/ta)*100,0),
BANSA = round((bansa/ta)*100,0), NS = round((ns/ta)*100,0),
RS = round((rs/ta)*100,0), TestArea = round((eta/ta)*100,0))
bansa[1]
bansa[BB == 1564]
cca_area <- length(cca.map[cca.map == 2])
bansa_area <- length(bansa.map[bansa.map == 20])
mist_area <- length(mist.map[mist.map == 200])
ns_area <- length(ns.map[ns.map == 2000])
rs_area <- length(rs.map[rs.map == 20000])
eta_area <- length(eta.map[eta.map == 200000])
bansa_area
xx <- 50#use 50% as a cutoff
cca_bbArea <- sum(cca[cc$CCA > xx])
bansa_bbArea <- sum(bansa[cc$BANSA > xx])
mist_bbArea <- sum(mist[cc$MIST > xx])
ns_bbArea <- sum(ns[cc$NS > xx])
rs_bbArea <- sum(rs[cc$RS > xx])
eta_bbArea <- sum(eta[cc$TestArea > xx])
bansa_bbArea
round((cca_bbArea/cca_area)*100,1)
round((bansa_bbArea/bansa_area)*100,1)
round((mist_bbArea/mist_area)*100,1)
round((ns_bbArea/ns_area)*100,1)
round((rs_bbArea/rs_area)*100,1)
round((eta_bbArea/eta_area)*100,1)
cca_b <- ifelse(cc$CCA > xx, 2, 1)
bansa_b <- ifelse(cc$BANSA > xx, 2, 1)
mist_b <- ifelse(cc$MIST > xx, 2, 1)
ns_b <- ifelse(cc$NS > xx, 2, 1)
rs_b <- ifelse(cc$RS > xx, 2, 1)
eta_b <- ifelse(cc$TestArea > xx, 2, 1)
bansa_b[BB == 1564]
BurnBlock <- data.frame(BurnBlock = BB, Area = ta, CCA = cca_b,
MIST = mist_b, BANSA = bansa_b, NS = ns_b, RS = rs_b,
TestArea = eta_b)
write.table(BurnBlock, file = "C:/usfs_sef_data_csv/sef_lut_pathways3_burnBlocks.csv",
append = FALSE, quote = TRUE, sep = ",", eol = "\n", na = "NA",
dec = ".", row.names = FALSE,col.names = T, qmethod =
c("escape", "double"))#
rpois(1, 29.18953)
rpois(1, 29.18953)
rpois(1, 29.18953)
rpois(1, 29.18953)
rpois(1, 29.18953)
rpois(1, 29.18953)
rpois(1, 29.18953)
rpois(1, 29.18953)
rpois(1, 29.18953)
rpois(1, 29.18953)
rpois(1, 29.18953)
rpois(1, 29.18953)
set.seed(198191): rpois(1, 29.18953)
set.seed(198191); rpois(1, 29.18953)
set.seed(198191); rpois(1, 29.18953)
set.seed(198191); rpois(1, 29.18953)
set.seed(198191); rpois(1, 29.18953)
set.seed(198191); rpois(1, 29.18953)
set.seed(198191); rpois(1, 29.18953)
set.seed(198191); rpois(1, 29.18953)
set.seed(198191); rpois(1, 29.18953)
set.seed(198191); rpois(1, 29.18953)
set.seed(198191); rpois(1, 29.18953)
set.seed(198191); rpois(1, 29.18953)
set.seed(198191); rpois(1, 29.18953)
set.seed(198191); rpois(1, 29.18953)
set.seed(198191); rpois(1, 29.18953)
set.seed(198191); rpois(1, 29.18953)
set.seed(198191): rpois(1, 29.18953)
rpois(1, 29.18953)
rpois(1, 29.18953)
rpois(1, 29.18953)
rpois(1, 29.18953)
rpois(1, 29.18953)
rpois(1, 29.18953)
rpois(1, 29.18953)
rpois(1, 29.18953)
set.seed(198191): rpois(1, 29.18953)
set.seed(198191): rpois(1, 29.18953)
rpois(1, 29.18953)
set.seed(198191): rpois(1, 29.18953)
set.seed(198191): rpois(1, 29.18953)
set.seed(198191): rpois(1, 29.18953)
set.seed(198191): rpois(1, 29.18953)
set.seed(198191): rpois(1, 29.18953)
set.seed(198191): rpois(1, 29.18953)
rpois(1, 29.18953)
rpois(1, 29.18953)
set.seed(198191): rpois(1, 29.18953)
set.seed(198191): rpois(1, 29.18953)
set.seed(198191): rpois(1, 29.18953)
rpois(1, 29.18953)
rpois(1, 29.18953)
rpois(1, 29.18953)
rpois(1, 10)
rpois(10, 10)
set.seed(2)
rpois(10,10)
rpois(10,10)
set.seed(2030)
rpois(10,10)
args <- read.table("sef_lut_schedule_treatment.csv", header=TRUE,
sep=",", na.strings="NA", dec=".", strip.white=TRUE)
args <- args[30,]
#Set working directory
setwd("C:/Users/jcronan/Documents/GitHub/EglinAirForceBase")
#Accept arguments from Rscript/command line
#args <- commandArgs(TRUE)
args <- read.table("sef_lut_schedule_treatment.csv", header=TRUE,
sep=",", na.strings="NA", dec=".", strip.white=TRUE)
args <- args[30,]
set.seed(args[1])#this prevents script from producing identical random numbers
#when running in parallel on the same machine.
args[1]
paste(args[1])
as.numeric(args[1])
set.seed(as.numeric(args[1]))
