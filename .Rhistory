if(r101 > 0)                                                                 #
{                                                                            #
r101 <- r101
break
} else                                                                       #
{                                                                            #
r101 <- r101
}                                                                            #
##############################################################################
##############################################################################
##############################################################################
#Post-wildfire processing >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
#Update files if there were disturbances in year[a].
if(length(loopE.NewStand) > 0)
{
st1.11 <- cbind(st1.11, system.time({#58
#Update files based on time-since-last-treatment>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
#Show max time-since-last-treatment before state transitions for each fuelbed
max_tslt <- fuelbed_lut$max_tslt[fuelbed_lut$fuelbed %in% tslt.Fuelbeds]
#List each of the fuelbeds corresponding with tslt object above
max_tslt_fb <- fuelbed_lut$fuelbed[fuelbed_lut$fuelbed %in% tslt.Fuelbeds]
#Expand to the max tslt object for each row in tslt.List
max_tslt_x_stand <- max_tslt[match(tslt.Fuelbeds, max_tslt_fb)]
}))#58
#Crash model is Fuelbed.List turned into a list()
if(length(max_tslt_x_stand) != length(tslt.List))
{
r101 <- "inconcistency in tslt tracking"
break
} else
{
r101 <- r101
}
st1.12 <- cbind(st1.12, system.time({#59
#List stand numbers for stands that will transition.
replace_stands <- tslt.Stands[tslt.List > max_tslt_x_stand]
#List fuelbeds of stands that will transition.
replace_fbs <- tslt.Fuelbeds[tslt.List > max_tslt_x_stand]
#List unique current fuelbeds for stands that will transition.
old_fbs <- fuelbed_lut$fuelbed[fuelbed_lut$fuelbed %in% replace_fbs]
#List unique new fuelbeds for stands that will transition.
new_fbs <- fuelbed_lut$post_1[fuelbed_lut$fuelbed %in% replace_fbs]
#Expand new unique fuelbeds to the number of stands that will transition.
new_fbs_x_stand <- new_fbs[match(replace_fbs, old_fbs)]
#Replace current fuelbeds with new ones in cases where tslt exceeds limit for
#state.
tslt.Fuelbeds[tslt.Stands %in% replace_stands] <- new_fbs_x_stand
#Order tslt objects by stand number before you apply it to .List objects
tslt.List <- tslt.List[order(tslt.Stands)]
tslt.Fuelbeds <- tslt.Fuelbeds[order(tslt.Stands)]
tslt.Stands <- sort(tslt.Stands)
#Apply changes to f.map and Fuelbed.List
vt.map <- s.map[s.map %in% tslt.Stands]
v.tslt <- tslt.Fuelbeds[match(vt.map, tslt.Stands)]
f.map[s.map %in% tslt.Stands] <- v.tslt
Fuelbed.List[Stand.List %in% tslt.Stands] <- tslt.Fuelbeds
}))#59
st1.13 <- cbind(st1.13, system.time({#60
#Remove stands that have been overwritten
tslt.List <- tslt.List[!(is.na(match(tslt.Stands, Stand.List[Stand.List %in% tslt.Stands])))]
tslt.Fuelbeds <- tslt.Fuelbeds[!(is.na(match(tslt.Stands, Stand.List[Stand.List %in% tslt.Stands])))]
tslt.Stands <- tslt.Stands[!(is.na(match(tslt.Stands, Stand.List[Stand.List %in% tslt.Stands])))]
#Remove rows where fuelbeds no longer represent a silvicultural treatment
tslt.List <- tslt.List[which(mapply(function(y)
{as.numeric(strsplit(as.character(y), "")[[1]])[4]}
, tslt.Fuelbeds) %in% c(2,3,4,6,7,8) == T)]
tslt.Stands <- tslt.Stands[which(mapply(function(y)
{as.numeric(strsplit(as.character(y), "")[[1]])[4]}
, tslt.Fuelbeds) %in% c(2,3,4,6,7,8) == T)]
tslt.Fuelbeds <- tslt.Fuelbeds[which(mapply(function(y)
{as.numeric(strsplit(as.character(y), "")[[1]])[4]}
, tslt.Fuelbeds) %in% c(2,3,4,6,7,8) == T)]
}))#60
st1.14 <- cbind(st1.14, system.time({#61
#Code below replaces loop, vene though there are more lines it should run way faster.
loopE_crownFire <- loopE[loopE$Fire == 2,]
#Object shows fuelbeds associated with each new stand number created by
#disturbances in year[a].
FB_burned.by.crownFire_1 <- Fuelbed.List[Stand.List %in% loopE_crownFire$ReplacedStand]
SN_burned.by.crownFire_1 <- Stand.List[Stand.List %in% loopE_crownFire$ReplacedStand]
FB_burned.by.crownFire_2 <- FB_burned.by.crownFire_1[match(loopE_crownFire$ReplacedStand,
SN_burned.by.crownFire_1)]
#Add SN_burned.by.crownFire_2 to loopE_crownFire data frame
loopE_crownFire <- data.frame(loopE_crownFire, AffectedFuelbed = FB_burned.by.crownFire_2)
#Sort data frame by new stands
loopE_crownFire <- loopE_crownFire[order(loopE_crownFire$NewStand),]#probably unecessary
#seperate out new stands from s.map, lists occurrences of new stands from min to max coords.
crownFire_standsXpixel <- s.map[s.map %in% loopE_crownFire$NewStand]
#List of row numbers in fuelbed lookup table where fuelbeds need to be updated based on treatment
burned.fuelbeds.positions <- which(fuelbed_lut$fuelbed %in% loopE_crownFire$AffectedFuelbed)
#Fuelbeds that may be updated corresponding with row numbers in burned.fuelbeds.positions
fuelbeds.burned.in.crownFire <- fuelbed_lut$fuelbed[fuelbed_lut$fuelbed %in% FB_burned.by.crownFire_2]
#row numbers in fuelbed lookup table corresponding with each existing fuelbed in each new stand
burned.fuelbed.positionsXpixel <- burned.fuelbeds.positions[match(loopE_crownFire$AffectedFuelbed,
fuelbeds.burned.in.crownFire)]
#Activate when you can differentiate between crown fire and surface fire
crownFire_regen <- fuelbed_lut$crown_fire[burned.fuelbed.positionsXpixel]
#Lists occurrences of new fuelbeds from min to max coords.
crownFire_regenXpixel <- crownFire_regen[match(crownFire_standsXpixel, loopE_crownFire$NewStand)]
#Replace old fuelbeds with new ones in f.map
f.map[s.map %in% loopE_crownFire$NewStand] <- crownFire_regenXpixel
#Re-order loopE data frame by old stands because that is the order of ages in crownFire_newAge_1.
loopE_crownFire <- loopE_crownFire[order(loopE_crownFire$ReplacedStand),]
#List ages associated with each stand that has been affected by crown fire
#These will be used to update Age.List
crownFire_oldAge_1 <- Age.List[Stand.List %in% loopE_crownFire$ReplacedStand]
crownFire_oldAge_2 <- crownFire_oldAge_1[match(loopE_crownFire$ReplacedStand, SN_burned.by.crownFire_1)]
#List new age for crown fire stands
crownFire_newAge <- rep(0, length(crownFire_oldAge_2))
#Add crownFire_newAge_2 to loopE data.frame
loopE_crownFire <- data.frame(loopE_crownFire, oldAge = crownFire_oldAge_2)
#Add crownFire_regen to loopE data.frame
loopE_crownFire <- data.frame(loopE_crownFire, newFuelbed = crownFire_regen)
#Add crownFire_newAge_2 to loopE data.frame
loopE_crownFire <- data.frame(loopE_crownFire, newAge = crownFire_newAge)
#Re-order loopE data frame by new stands.
loopE_crownFire <- loopE_crownFire[order(loopE_crownFire$NewStand),]
}))#61
st1.15 <- cbind(st1.15, system.time({#62
#List stands that have been altered by disturbances.
ss2 <- loopE.ReplacedStand
standd <- sort(unique(ss2))#there can be duplicates, this will mess up the shortcut in a9
sb <- summarize(loopE.Area,ss2,sum)#sum areas for duplicates.
saread <- as.vector(sb[,2])
smud <- mapply(function(y) MU.List[Stand.List == y], loopE.ReplacedStand)
#Isolate stands affected by surface fire
loopE_surfaceFire <- loopE[loopE$Fire == 1,]
loopE_surfaceFire <- loopE_surfaceFire[order(loopE_surfaceFire$NewStand),]#probably unecessary
#Add fuelbed and age info (needed to update .List objects)
StandNumber_surfaceFire_1 <- Stand.List[Stand.List %in% loopE_surfaceFire$ReplacedStand]
Fuelbed_surfaceFire_1 <- Fuelbed.List[Stand.List %in% loopE_surfaceFire$ReplacedStand]
Fuelbed_surfaceFire_2 <- Fuelbed_surfaceFire_1[match(loopE_surfaceFire$ReplacedStand,
StandNumber_surfaceFire_1)]
Age_surfaceFire_1 <- Age.List[Stand.List %in% loopE_surfaceFire$ReplacedStand]
Age_surfaceFire_2 <- Age_surfaceFire_1[match(loopE_surfaceFire$ReplacedStand,
StandNumber_surfaceFire_1)]
}))#62
st1.16 <- cbind(st1.16, system.time({#63
#Create new data frame. At this point new fuelbeds and new ages are old, these are
#just placeholders until further down this loop when surface fire impacts are assessed
#using mFRI.
loopE_surfaceFire <- data.frame(loopE_surfaceFire,
AffectedFuelbed = Fuelbed_surfaceFire_2,
oldAge = Age_surfaceFire_2, newFuelbed = Fuelbed_surfaceFire_2,
newAge = Age_surfaceFire_2)
#Combine surface fire and crown fire tables
loopE_allFire <- rbind(loopE_surfaceFire, loopE_crownFire)
loopE_allFire <- loopE_allFire[order(loopE_allFire$NewStand),]
#Shelve fire history for stands that have been impacted by disturbance
new_mfri_vec <- mapply(function(y) mfri.Matrix[Stand.List == y,], loopE_allFire$ReplacedStand)
nmvd <- t(new_mfri_vec)
#Add a fire for stands that were burned in wildfires
nmvd[,30] <- 1
}))#63
st1.17 <- cbind(st1.17, system.time({#64
#Change stand properties as needed for treatments.
#Create a data.frame so you can switch order from stand number to
#order in which stand was added.
#ID2.List <- 1:length(Stand.List)
#TL2 <- data.frame(ID = ID2.List, Stand = Stand.List, Area = Area.List)
#Order by stand number
#TL2 <- TL2[order(TL2$Stand),]
#Subtract area of new stands from corresponding old stands
#TL2$Area[TL2$Stand %in% standd] <- TL2$Area[TL2$Stand %in% standd] - saread
Area.List[Stand.List %in% standd] <- Area.List[Stand.List %in% standd] - saread
#Reorder by order stands were added
#TL2 <- TL2[order(TL2$ID),]
#Replace Area.List with updated object
#Area.List <- TL2$Area
#Update list to remove any stands that have been overwritten.
Stand.List <- Stand.List[(Area.List == 0) == F]
Fuelbed.List <- Fuelbed.List[(Area.List == 0) == F]
Age.List <- Age.List[(Area.List == 0) == F]
#T1E.List <- T1E.List[(Area.List == 0) == F]
#T2E.List <- T2E.List[(Area.List == 0) == F]
#D1E.List <- D1E.List[(Area.List == 0) == F]
#D2E.List <- D2E.List[(Area.List == 0) == F]
Coord.List <- Coord.List[(Area.List == 0) == F]
MU.List <- MU.List[(Area.List == 0) == F]
mfri.Matrix <- mfri.Matrix[(Area.List == 0) == F,]
mfri_lower.List <- mfri_lower.List[(Area.List == 0) == F]
mfri_upper.List <- mfri_upper.List[(Area.List == 0) == F]
Area.List <- Area.List[(Area.List == 0) == F]
#Update list to add new stands.
Stand.List <- c(Stand.List, loopE_allFire$NewStand)
Fuelbed.List <- c(Fuelbed.List, loopE_allFire$newFuelbed)
Age.List <- c(Age.List, loopE_allFire$newAge)
#List fuelbeds that need to be updated.
#pdaFB_a20 <- pda$pre[pda$pre %in% loopE_allFire$newFuelbed]
#List corresponding updated age restrictions
#pdaTH_a20 <- pda$thin[pda$pre %in% loopE_allFire$newFuelbed]
#List occurences of age restriction for each new stand
#v.THIN_a20 <- pdaTH_a20[match(loopE_allFire$newFuelbed,pdaFB_a20)]
#Update
#T1E.List <- c(T1E.List,v.THIN_a20)
#List corresponding updated age restrictions
#pdaHE_a20 <- pda$herb[pda$pre %in% loopE_allFire$newFuelbed]
#List occurences of age restriction for each new stand
#v.HERB_a20 <- pdaHE_a20[match(loopE_allFire$newFuelbed,pdaFB_a20)]
#Update
#T2E.List <- c(T2E.List, v.HERB_a20)
#List corresponding updated age restrictions
#pdaSF_a20 <- pda$sfire[pda$pre %in% loopE_allFire$newFuelbed]
#List occurences of age restriction for each new stand
#v.SFIRE_a20 <- pdaSF_a20[match(loopE_allFire$newFuelbed,pdaFB_a20)]
#Update
#D1E.List <- c(D1E.List, v.SFIRE_a20)
#List corresponding updated age restrictions
#pdaCF_a20 <- pda$cfire[pda$pre %in% loopE_allFire$newFuelbed]
#List occurences of age restriction for each new stand
#v.CFIRE_a20 <- pdaCF_a20[match(loopE_allFire$newFuelbed,pdaFB_a20)]
#Update
#D2E.List <- c(D2E.List, v.CFIRE_a20)
}))#64
st1.18 <- cbind(st1.18, system.time({#65
#List new stand occurrences in s.map
vs.map_a20 <- s.map[s.map %in% loopE.NewStand]
#List corresponding coordinates (l.map) for new stand occurrences in s.map
vl.map_a20 <- l.map[s.map %in% loopE.NewStand]
#Use summarize function (w/ min()) to select a single coordinate value for each new stand.
v.Coord_a20a <- summarize(vl.map_a20,vs.map_a20,min)
#Subset coordinates
v.Coord_a20b <- as.vector(v.Coord_a20a[,2])
#Update
Coord.List <- c(Coord.List,v.Coord_a20b)
MU.List <- c(MU.List, smud)
mfri.Matrix <- rbind(mfri.Matrix,nmvd)
mfri.List <- apply(mfri.Matrix,1,sum)
mfri.List <- round(30/mfri.List,0)
mfri.List <- ifelse(mfri.List == Inf, 32, mfri.List)
#Update
mfri_lower.List <- c(mfri_lower.List,
fuelbed_lut$mfri_shortens[match(loopE_allFire$newFuelbed,
fuelbed_lut$fuelbed)])
#Select option 1 for fuelbed transition when mfri lengthens
mfri_lengthens_1 <- fuelbed_lut$mfri_lengthens_1[match(loopE_allFire$newFuelbed,
fuelbed_lut$fuelbed)]
#Select option 2 for fuelbed transition when mfri lengthens
mfri_lengthens_2 <- fuelbed_lut$mfri_lengthens_2[match(loopE_allFire$newFuelbed,
fuelbed_lut$fuelbed)]
#Randomly choose between option 1 and 2 for each fuelebd.
mfri_lengthens <- apply(matrix(data = c(mfri_lengthens_1,
mfri_lengthens_2),length(mfri_lengthens_1), 2),
1, sample, size = 1)
#Update
mfri_upper.List <- c(mfri_upper.List, mfri_lengthens)
#Update
Area.List <- c(Area.List,loopE.Area)
#order .List objects by stand number
Fuelbed.List <- Fuelbed.List[order(Stand.List)]
MU.List <- MU.List[order(Stand.List)]
Area.List <- Area.List[order(Stand.List)]
mfri.Matrix <- mfri.Matrix[order(Stand.List),]
Age.List <- Age.List[order(Stand.List)]
mfri_lower.List <- mfri_lower.List[order(Stand.List)]
mfri_upper.List <- mfri_upper.List[order(Stand.List)]
Stand.List <- sort(Stand.List)
#Remove stands that have been overwritten
tslt.List <- tslt.List[!(is.na(match(tslt.Stands, Stand.List[Stand.List %in% tslt.Stands])))]
tslt.Fuelbeds <- tslt.Fuelbeds[!(is.na(match(tslt.Stands, Stand.List[Stand.List %in% tslt.Stands])))]
tslt.Stands <- tslt.Stands[!(is.na(match(tslt.Stands, Stand.List[Stand.List %in% tslt.Stands])))]
#Update time-since-last-treatment list and associated stand list
tslt.List <- c(tslt.List, rep(0, length(
loopE_allFire$NewStand[mapply(function(y)
{as.numeric(strsplit(as.character(y), "")[[1]])[4]}
, loopE_allFire$AffectedFuelbed) %in% c(2,3,4,6,7,8)])))
tslt.Stands <- c(tslt.Stands, loopE_allFire$NewStand[mapply(function(y)
{as.numeric(strsplit(as.character(y), "")[[1]])[4]}
, loopE_allFire$AffectedFuelbed) %in% c(2,3,4,6,7,8)])
tslt.Fuelbeds <- c(tslt.Fuelbeds, loopE_allFire$AffectedFuelbed[mapply(function(y)
{as.numeric(strsplit(as.character(y), "")[[1]])[4]}
, loopE_allFire$AffectedFuelbed) %in% c(2,3,4,6,7,8)])
}))#65
st1.19 <- cbind(st1.19, system.time({#66
##############################################################################
##############################################################################
##############################################################################
#ONLY TO DIAGNOSE ERRORS FROM MODEL RUN 101                                 #
#DRAG ON TIME, REMOVE AFTER ERRORS DIAGNOSED                                #
if(any(c(length(Stand.List),
length(Fuelbed.List),
length(mfri.List),
length(MU.List),
#length(T1E.List),
#length(T2E.List),
#length(D1E.List),
#length(D2E.List),
length(Area.List),
length(mfri_lower.List),
length(mfri_upper.List),
length(Age.List)) != (length(unique(as.vector(s.map)))-1)) == T)
{
r101 <- 3
break
} else
{
r101 <- ifelse(any(s.map < 0 & s.map > -9999),33,0)
}
##############################################################################
##############################################################################
##############################################################################
}))#66
st1.20 <- cbind(st1.20, system.time({#67
#Update fuelbeds based on impacts of changing mean fire return interval.
#Make a copy of the Fuelbed.List
feof <- Fuelbed.List
#Create a parelle list that shows lower bound of mFRI for each stand
mfri_lower <- fuelbed_lut$mfri_lower[match(feof,fuelbed_lut$fuelbed)]
#Create a parellel list that shows upper bound of mFRI for each stand
mfri_upper <- fuelbed_lut$mfri_upper[match(feof,fuelbed_lut$fuelbed)]
#Replace fuelbed with one representing a more frequent fire regime if the mFRI is shorter
#than the lower limit for the current fuelbed.
feof[mfri.List <  mfri_lower] <- mfri_lower.List[mfri.List < mfri_lower]
#Replace fuelbed with one representing a less frequent fire regime if the mFRI is longer
#than the lower limit for the current fuelbed.
feof[mfri.List > mfri_upper] <- mfri_upper.List[mfri.List > mfri_upper]
#Update f.map
#Improved function to update f.map based on mFRI. Former code used a for()
s.SL <- Stand.List[Fuelbed.List != feof]
feof2 <- feof[Fuelbed.List != feof]
vs.map <- s.map[s.map %in% s.SL]
v.feof2 <- feof2[match(vs.map, s.SL)]
f.map[s.map %in% s.SL] <- v.feof2
Fuelbed.List <- feof
}))#67
} else
{
#Update files based on time-since-last-treatment>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
#Show max time-since-last-treatment before state transitions for each fuelbed
max_tslt <- fuelbed_lut$max_tslt[fuelbed_lut$fuelbed %in% tslt.Fuelbeds]
#List each of the fuelbeds corresponding with tslt object above
max_tslt_fb <- fuelbed_lut$fuelbed[fuelbed_lut$fuelbed %in% tslt.Fuelbeds]
#Expand to the max tslt object for each row in tslt.List
max_tslt_x_stand <- max_tslt[match(tslt.Fuelbeds, max_tslt_fb)]
#Crash model is Fuelbed.List turned into a list()
if(length(max_tslt_x_stand) != length(tslt.List))
{
r101 <- "inconcistency in tslt tracking"
break
} else
{
r101 <- r101
}
#List stand numbers for stands that will transition.
replace_stands <- tslt.Stands[tslt.List > max_tslt_x_stand]
#List fuelbeds of stands that will transition.
replace_fbs <- tslt.Fuelbeds[tslt.List > max_tslt_x_stand]
#List unique current fuelbeds for stands that will transition.
old_fbs <- fuelbed_lut$fuelbed[fuelbed_lut$fuelbed %in% replace_fbs]
#List unique new fuelbeds for stands that will transition.
new_fbs <- fuelbed_lut$post_1[fuelbed_lut$fuelbed %in% replace_fbs]
#Expand new unique fuelbeds to the number of stands that will transition.
new_fbs_x_stand <- new_fbs[match(replace_fbs, old_fbs)]
#Replace current fuelbeds with new ones in cases where tslt exceeds limit for
#state.
tslt.Fuelbeds[tslt.Stands %in% replace_stands] <- new_fbs_x_stand
#Order tslt objects by stand number before you apply it to .List objects
tslt.List <- tslt.List[order(tslt.Stands)]
tslt.Fuelbeds <- tslt.Fuelbeds[order(tslt.Stands)]
tslt.Stands <- sort(tslt.Stands)
#Apply changes to f.map and Fuelbed.List
vt.map <- s.map[s.map %in% tslt.Stands]
v.tslt <- tslt.Fuelbeds[match(vt.map, tslt.Stands)]
f.map[s.map %in% tslt.Stands] <- v.tslt
Fuelbed.List[Stand.List %in% tslt.Stands] <- tslt.Fuelbeds
#Remove stands that have been overwritten
tslt.List <- tslt.List[!(is.na(match(tslt.Stands, Stand.List[Stand.List %in% tslt.Stands])))]
tslt.Fuelbeds <- tslt.Fuelbeds[!(is.na(match(tslt.Stands, Stand.List[Stand.List %in% tslt.Stands])))]
tslt.Stands <- tslt.Stands[!(is.na(match(tslt.Stands, Stand.List[Stand.List %in% tslt.Stands])))]
#Remove rows where fuelbeds no longer represent a silvicultural treatment
tslt.List <- tslt.List[which(mapply(function(y)
{as.numeric(strsplit(as.character(y), "")[[1]])[4]}
, tslt.Fuelbeds) %in% c(2,3,4,6,7,8) == T)]
tslt.Stands <- tslt.Stands[which(mapply(function(y)
{as.numeric(strsplit(as.character(y), "")[[1]])[4]}
, tslt.Fuelbeds) %in% c(2,3,4,6,7,8) == T)]
tslt.Fuelbeds <- tslt.Fuelbeds[which(mapply(function(y)
{as.numeric(strsplit(as.character(y), "")[[1]])[4]}
, tslt.Fuelbeds) %in% c(2,3,4,6,7,8) == T)]
}
#Post-wildfire processing >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
#Update files based on succession>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
st1.21 <- cbind(st1.21, system.time({#68
#Identify potential changes in fuelbeds based on succession pathways.
pmuf <- mapply(function(x) ifelse(
Age.List[x] > fuelbed_lut$succession_max[fuelbed_lut$fuelbed == Fuelbed.List[x]],
ifelse(fuelbed_lut$succession_post_2[fuelbed_lut$fuelbed == Fuelbed.List[x]] > 0,
resample(c(fuelbed_lut$succession_post_1[fuelbed_lut$fuelbed == Fuelbed.List[x]],
fuelbed_lut$succession_post_2[fuelbed_lut$fuelbed == Fuelbed.List[x]]),1),
fuelbed_lut$succession_post_1[fuelbed_lut$fuelbed == Fuelbed.List[x]]),
Fuelbed.List[x]),1:length(Stand.List))
}))#68
st1.22 <- cbind(st1.22, system.time({#69
#Update f.map
#Improved function to update f.map based on mFRI. Former code used a for()
s.SL2 <- Stand.List[Fuelbed.List != pmuf]
pmuf2 <- pmuf[Fuelbed.List != pmuf]
vs.map2 <- s.map[s.map %in% s.SL2]
v.pmuf2 <- pmuf2[match(vs.map2, s.SL2)]
f.map[s.map %in% s.SL2] <- v.pmuf2
Fuelbed.List[Stand.List %in% s.SL2] <- pmuf2
}))#69
st1.23 <- cbind(st1.23, system.time({#70
#Kill model if any fuelbed numbers are < 0. This means there is an error in the lookup
#table.
if(any(Fuelbed.List < 0) == T)
{
broken.stands <- Stand.List[Fuelbed.List < 0]
f.orig <- matrix(scan(paste("inputs/sef_fmap_v2_",rows,"x",cols,".txt",
sep = ""),skip = fh.adj),ncol=cols,byrow=T)#16
break
} else
{
#don't break
}
#Update D.List
#D.List <- cbind(T1E.List, T2E.List, D1E.List, D2E.List)
#Create maps for interval years.
if((a %% Interval) == 0)
{
#  #Save Fuelbed Map (f.map).
dt <- Sys.Date()
tm <- format(Sys.time(), format = "%H.%M.%S",
tz = "", usetz = FALSE)
write.table(s.map, file = paste(output_path, "sef_smap_run_", run, "_",
dt,"_",tm,"_R",rows,"xC",cols,"_Y",a,".txt",sep = ""),
append = FALSE, quote = TRUE, sep = " ", eol = "\n", na = "NA",
dec = ".", row.names = FALSE,col.names = FALSE, qmethod =
c("escape", "double"))#
write.table(f.map, file = paste(output_path, "sef_fmap_run_", run, "_",
dt,"_",tm,"_R",rows,"xC",cols,"_Y",a,".txt",sep = ""),
append = FALSE, quote = TRUE, sep = " ", eol = "\n", na = "NA",
dec = ".", row.names = FALSE,col.names = FALSE, qmethod =
c("escape", "double"))#
}
}))#70
} #1.0.0 ---------------------------------------------------------------------------
})#71
#}
#entireScript()
#Calculate total for each segment
systemTime <- matrix(data = NA, 3,70)
rownames(systemTime) <-(rownames(st1.1[1:3,]))
colnames(systemTime) <- c("L1_976_1207", "L2_1221_1342", "L2_1241_1342", "L2_1349_1390", "L3_1405_1428",
"L3_1434_1505", "L3_1510_1541", "L4_1549_1554", "L4_1560_1566_GPU", "L4_1567_1572",
"L4_1579_1601", "L4_1602_1628", "L4_1635_1661", "L3_1689_1719", "L2_1746_1788",
"L1_1927_1934", "L1_1942_1958", "L1_1959_1991", "L1_1992_2019", "L1_2020_2029",
"L1_2030_2046", "L1_2047_2064", "L1_2065_2151", "L1_2152_2175", "L8_2202_2241",
"L9_2257_2288", "L9_2294_2303", "L9_2308_2323", "L9_2324_2421", "L9_2441_2598",
"L9_2613_2637", "L9_2643_2701", "L10_2717_2775", "L10_2780_2789_GPU", "L10_2790_2794",
"L10_2795_2799", "L10_2800_2807", "L10_2808_2815", "L10_2816_2821", "L10_2822_2828",
"L10_2851_2858", "L10_2859_2869", "L10_2870_2914", "L9_2935_2996", "L11_3004_3009",
"L11_3015_3019_GPU", "L11_3020_3025", "L11_3026_3124", "L9_3149_3178", "L9_3179_3208",
"L9_3209_3238", "L9_3249_3281", "L9_3282_3290", "L9_3291_3315", "L9_3316_3343",
"L8_3359_3377", "L1_3471_3480", "L1_3481_3512", "L1_3513_3527", "L1_3528_3537",
"L1_3538_3547", "L1_3548_3564", "L1_3565_3588", "L1_3589_3668", "L1_3669_3699",
"L1_3700_3718", "L1_3728_3740", "L1_3741_3755", "L1_3756_3787", "L0_969_3791")
objectTitle <- c("st1.1", "st2.1", "st2.2", "st2.3", "st3.1", "st3.2", "st3.3", "st4.1", "st4.2", "st4.3",
"st4.4", "st4.5", "st4.6", "st3.4", "st2.4", "st1.2", "st1.3", "st1.4", "st1.5", "st1.6",
"st1.7", "st1.8", "st1.9", "st1.10", "st8.1", "st9.1", "st9.2", "st9.3", "st9.4", "st9.5",
"st9.6", "st9.7", "st10.1", "st10.2", "st10.3", "st10.4", "st10.5", "st10.6", "st10.7",
"st10.8", "st10.9", "st10.10", "st10.11", "st9.8", "st11.1", "st11.2", "st11.3", "st11.4",
"st9.9", "st9.10", "st9.11", "st9.12", "st9.13", "st9.14", "st9.15", "st8.2", "st1.11",
"st1.12", "st1.13", "st1.14", "st1.15", "st1.16", "st1.17", "st1.18", "st1.19", "st1.20",
"st1.21", "st1.22", "st1.23")
for(a in 1:69)
{
aa <- eval(as.name(objectTitle[a]))
for(i in 1:3)
{
systemTime[i,a] <- sum(aa[i,], na.rm = T)
}
}
systemTime[,70] <- as.vector(loop_st[1:3])
percentSystemTime <- matrix(data = NA, 3,70)
rownames(percentSystemTime) <-(rownames(st1.1[1:3,]))
colnames(percentSystemTime) <- c("L1_976_1207", "L2_1221_1342", "L2_1241_1342", "L2_1349_1390", "L3_1405_1428",
"L3_1434_1505", "L3_1510_1541", "L4_1549_1554", "L4_1560_1566_GPU", "L4_1567_1572",
"L4_1579_1601", "L4_1602_1628", "L4_1635_1661", "L3_1689_1719", "L2_1746_1788",
"L1_1927_1934", "L1_1942_1958", "L1_1959_1991", "L1_1992_2019", "L1_2020_2029",
"L1_2030_2046", "L1_2047_2064", "L1_2065_2151", "L1_2152_2175", "L8_2202_2241",
"L9_2257_2288", "L9_2294_2303", "L9_2308_2323", "L9_2324_2421", "L9_2441_2598",
"L9_2613_2637", "L9_2643_2701", "L10_2717_2775", "L10_2780_2789_GPU", "L10_2790_2794",
"L10_2795_2799", "L10_2800_2807", "L10_2808_2815", "L10_2816_2821", "L10_2822_2828",
"L10_2851_2858", "L10_2859_2869", "L10_2870_2914", "L9_2935_2996", "L11_3004_3009",
"L11_3015_3019_GPU", "L11_3020_3025", "L11_3026_3124", "L9_3149_3178", "L9_3179_3208",
"L9_3209_3238", "L9_3249_3281", "L9_3282_3290", "L9_3291_3315", "L9_3316_3343",
"L8_3359_3377", "L1_3471_3480", "L1_3481_3512", "L1_3513_3527", "L1_3528_3537",
"L1_3538_3547", "L1_3548_3564", "L1_3565_3588", "L1_3589_3668", "L1_3669_3699",
"L1_3700_3718", "L1_3728_3740", "L1_3741_3755", "L1_3756_3787", "L0_969_3791")
total <- as.vector(loop_st[1:3])
for(a in 1:69)
{
aa <- eval(as.name(objectTitle[a]))
for(i in 1:3)
{
percentSystemTime[i,a] <- round((sum(aa[i,], na.rm = T)/total[i]),4)*100
}
}
percentSystemTime[,70] <- round((as.vector(loop_st[1:3])/as.vector(loop_st[1:3])),4)*100
#  #Save Fuelbed Map (f.map).
dt <- Sys.Date()
tm <- format(Sys.time(), format = "%H.%M.%S",
tz = "", usetz = FALSE)
systemTime <- as.data.frame(systemTime)
write.csv(systemTime, file = paste(output_path, "SysTime_",
dt,"_",tm,"_R",rows,"xC",cols,"_Y",a,".csv",sep = ""),
quote = TRUE, eol = "\n", na = "NA", row.names = FALSE)#
percentSystemTime <- as.data.frame(percentSystemTime)
write.csv(percentSystemTime, file = paste(output_path, "percSysTime_",
dt,"_",tm,"_R",rows,"xC",cols,"_Y",a,".csv",sep = ""),
quote = TRUE, eol = "\n", na = "NA", row.names = FALSE)#
